<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rcpp | Wush筆記]]></title>
  <link href="http://wush978.github.com/blog/categories/rcpp/atom.xml" rel="self"/>
  <link href="http://wush978.github.com/"/>
  <updated>2013-01-11T15:46:46+08:00</updated>
  <id>http://wush978.github.com/</id>
  <author>
    <name><![CDATA[Wush978]]></name>
    <email><![CDATA[wush.978@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[xts and Rcpp]]></title>
    <link href="http://wush978.github.com/blog/2013/01/11/xts-and-rcpp/"/>
    <updated>2013-01-11T14:54:00+08:00</updated>
    <id>http://wush978.github.com/blog/2013/01/11/xts-and-rcpp</id>
    <content type="html"><![CDATA[<p>Here is my guideline to integrate xts with Rcpp in a R package.</p>

<p>Because the <code>xts_API</code> is written for c language, so we need to hack
somethings to make it work with c++.</p>

<h1>Modify <code>DESCRIPTION</code></h1>

<p><code>sh
Depends: xts, Rcpp
linkingTo: xts, Rcpp
</code></p>

<h1>Create files in <code>src</code> directory</h1>

<p>```c xts_api.c</p>

<h1>include &lt;xts.h></h1>

<h1>include &lt;xts_stubs.c></h1>

<p>```</p>

<p>```cpp xts_api.h
extern "C" {</p>

<h1>define class xts_class</h1>

<h1>include &lt;xts.h></h1>

<h1>undef class</h1>

<p>}</p>

<p>inline SEXP install(const char* x) {
  return Rf_install(x);
}</p>

<p>inline SEXP getAttrib(SEXP a, SEXP b) {
  return Rf_getAttrib(a, b);
}</p>

<p>inline SEXP setAttrib(SEXP a, SEXP b, SEXP c) {
  return Rf_setAttrib(a, b, c);
}
```</p>

<p>Without the macro, there will be  compile time error:
<code>
error: expected identifier before ‘)’ token
</code>
because <code>xts.h</code> use the keyword <code>class</code>.</p>

<p>Without the inline functions, there will be some compile time errors:
<code>
error: ‘install’ was not declared in this scope
error: ‘getAttrib’ was not declared in this scope
</code></p>

<p>Now, almost all API could be invoked in c++:</p>

<p>```cpp rcpp_test.cpp</p>

<h1>include &lt;Rcpp.h></h1>

<h1>include "xts_api.h"</h1>

<p>using namespace Rcpp;</p>

<p>RcppExport SEXP get_xts_index(SEXP x) {
  BEGIN_RCPP</p>

<p>  return GET_xtsIndex(x);</p>

<p>  END_RCPP
}
```</p>

<p>except <code>SET_xtsIndexClass(x, value)</code>:</p>

<p><code>sh compile time error
error: ‘xts_IndexvalueSymbol’ was not declared in this scope
</code></p>

<p>I guess that we should replace <code>xts_IndexvalueSymbol</code> with <code>xts_IndexClassSymbol</code></p>

<h2>Reference</h2>

<ul>
<li><code>file.show(system.file('api_example/README', package="xts"))</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RcppArmadillo]]></title>
    <link href="http://wush978.github.com/blog/2012/08/21/rcpparmadillo/"/>
    <updated>2012-08-21T20:08:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/21/rcpparmadillo</id>
    <content type="html"><![CDATA[<h1>Inroduction</h1>

<p>Recently I am exploring the linear algebra features provided in <a href="http://arma.sourceforge.net/">Armadillo</a> through <a href="http://dirk.eddelbuettel.com/code/rcpp.armadillo.html">RcppArmadillo</a>.</p>

<p>Here is the note for myself.</p>

<p>Note these functions are only my understanding of these operators and methods. I didn't check the source code of Armadillo and RcppArmadillo.</p>

<h1>Basic Elements and Methods</h1>

<p>``` cpp mat
arma::mat a(5, 5); // Initialize a 5 x 5 matrix.</p>

<p>a.fill(0); // fill it with 0
a.n_rows;    //!&lt; number of rows in the matrix (read-only)
a.n_cols;    //!&lt; number of columns in the matrix (read-only)
a.n_elem;    //!&lt; number of elements in the matrix (read-only)
a.vec_state; //!&lt; 0: matrix layout; 1: column vector layout; 2: row vector layout
a.mem;       //!&lt; pointer to memory used by the matrix (memory is read-only)</p>

<p>a.min();
a.max();
```</p>

<h1>Feature</h1>

<h2>Matrix Multiplication</h2>

<p><code>cpp Matrix Multiplication
const arma::mat operator*(const arma::mat&amp; x, const arma::mat&amp; y);
</code></p>

<h2>Transpose</h2>

<p>``` cpp Transpose
const arma::mat arma::trans(const arma::mat&amp; x);</p>

<p>// Methods of class arma::mat
// x.t() = arma::trans(x)
const arma::mat arma::mat::t();
```</p>

<h2>Inverse</h2>

<p><code>cpp Inverse
const arma::mat arma::pinv(const arma::mat&amp; x);
</code></p>

<h2>Sum of Square</h2>

<p>``` cpp Sum of Square
inline double sumOfSquare(arma::vec&amp; x) {</p>

<pre><code>return std::inner_product(x.begin(), x.end(), x.begin(), 0.0);
</code></pre>

<p>}
```</p>

<h2>Diagonal Vector</h2>

<p><code>cpp Diagonal Vector
const arma::colvec arma::diagvec(const arma::mat&amp; x);
</code></p>

<h2>Linear Regression</h2>

<p>``` cpp Linear Regression
/<em>*
 * @param X    the explanatory variables
 * @param y    the response variable
 * @return     the vector of regression coefficients
 </em>/
const arma::colvec arma::solve(const arma::mat&amp; X, const arma::vec&amp; y);</p>

<p>// Residuals
arma::colvec residuals = y - X * coef;</p>

<p>// Residual Sum of Square
double s2 = sumOfSquare(residuals);</p>

<p>// Std of Coef.
arma::colvec sderr = arma::sqrt(s2 *</p>

<pre><code>arma::diagvec(arma::pinv(arma::trans(X)*X)));
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
