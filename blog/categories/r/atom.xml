<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | Wush筆記]]></title>
  <link href="http://wush978.github.com/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://wush978.github.com/"/>
  <updated>2012-06-14T17:16:16+08:00</updated>
  <id>http://wush978.github.com/</id>
  <author>
    <name><![CDATA[Wush978]]></name>
    <email><![CDATA[wush.978@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[R debug]]></title>
    <link href="http://wush978.github.com/blog/2012/06/14/r-debug/"/>
    <updated>2012-06-14T01:11:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/06/14/r-debug</id>
    <content type="html"><![CDATA[<h1>簡介</h1>

<p>很少人能夠第一次寫程式就能寫對，就連最專業的程式設計師也會花大把大把的時間在除錯。
所以熟悉除錯的工具也是能夠顯著的提昇寫程式的效率。</p>

<p>其實作者我在寫這篇文章之前也完全沒用過除錯工具！想到又能提昇自己的coding效率又讓我熊熊的燃燒起來！！</p>

<h1>除錯函數</h1>

<p>R 提供了以下的除錯功能:</p>

<ul>
<li><code>traceback</code></li>
<li><code>browser</code></li>
<li><code>debug</code></li>
<li><code>trace</code></li>
</ul>


<p>就讓我來一個個探索吧！</p>

<h2>traceback</h2>

<p>所謂的traceback功能主要的目的，是找出錯誤發生時最後執行的函數：</p>

<p>``` r traceback-example-1
fail_func1 &lt;- function(size) {</p>

<pre><code>b &lt;- 5
b &lt;- b + size
b &lt;- b * 2
b &lt;- b^2
b
</code></pre>

<p>}
fail_func2 &lt;- function(size) {</p>

<pre><code>b &lt;- fail_func1(size)
a &lt;- sample(0:1,size,FALSE)
a
</code></pre>

<p>}
fail_func2(12)
traceback()
fail_func2('test')
traceback()
```</p>

<p>運行結果：</p>

<p>``` rconsole traceback-example-1-output</p>

<blockquote><p>fail_func2(12)
Error in sample(0:1, size, FALSE) :
  cannot take a sample larger than the population when 'replace = FALSE'
traceback()
2: sample(0:1, size, FALSE) at #3
1: fail_func2(12)
fail_func2('test')
Error in b + size : non-numeric argument to binary operator
traceback()
2: fail_func1(size) at #2
1: fail_func2("test")</p>

<p>```</p></blockquote>

<p>可以看出traceback確實的找出最後一個丟出錯誤的函數。</p>

<h2>browser</h2>

<p>traceback只能指出錯誤的發生處，並不能幫助使用者找出程式的錯誤。
接下來的<code>browser</code>指令則提供互動式的除錯功能：</p>

<ul>
<li>暫停程式碼的執行</li>
<li>讓使用者能察看某個時間點的變數狀態，甚至是修改變數狀態。此時以下的指令變成有特殊意義：

<ul>
<li><code>c</code> 讓程式繼續進行</li>
<li><code>n</code> 執行下一行</li>
<li><code>Q</code> 中斷</li>
</ul>
</li>
<li>繼續執行</li>
</ul>


<p>ps. 如果在中斷期間要查詢名稱為<code>c</code>、<code>n</code>、<code>Q</code>的變數內容，請用<code>print</code>指令。
但是我個人是認為不應該把變數取這類名稱！！</p>

<p>如果運行以下的指令：</p>

<p><code>r browser-example-1
global_env &lt;- 1
fail_func1 &lt;- function(size) {
  fail_func1_env &lt;- 5
  browser()
  fail_func1_env &lt;- 6
  fail_func1_env &lt;- 7
  fail_func1_env
}
fail_func2 &lt;- function(size) {
  fail_func2_env &lt;- 1
  b &lt;- fail_func1(size)
  a &lt;- sample(0:1,size,FALSE)
  a
}
fail_func2(12)
</code></p>

<p>應該會看到類似以下的結果：</p>

<p>``` rconsole browser-example-1-output</p>

<blockquote><p>fail_func2(12)
Called from: fail_func1(size)
Browse[1]> global_env
[1] 1
Browse[1]> fail_func1_env
[1] 5
Browse[1]> fail_func2_env
Error: object 'fail_func2_env' not found
Browse[1]> size
[1] 12
Browse[1]> n
debug at #4: fail_func1_env <- 6
Browse[2]> fail_func1_env
[1] 5
Browse[2]> n
debug at #5: fail_func1_env <- 7
Browse[2]> fail_func1_env
[1] 6
Browse[2]> n
debug at #6: fail_func1_env
Browse[2]> fail_func1_env
[1] 7
```</p></blockquote>

<p>在程式跑到<code>browser</code>時就暫停了。
因為<code>browser</code>是插入在<code>fail_func1</code>的第二行，所以變數應該和該時間點相同，
值得注意的是此時也只能存取該function environment內的變數</p>

<h2>debug</h2>

<p>我們可以把上一節的<code>browser</code>視為一種<em>中斷點</em>，
而<code>debug</code>函數則可以幫一個函數的每一行加入中斷點。
在對內建函數除錯的時候非常有用：</p>

<p><code>r debug-example-1
debug(lm)
lm(Sepal.Length~Species,iris)
</code></p>

<p>``` rconsole debug-example-1-output</p>

<blockquote><p>lm(Sepal.Length~Species,iris)
debugging in: lm(Sepal.Length ~ Species, iris)
debug: {</p>

<pre><code>ret.x &lt;- x
ret.y &lt;- y
</code></pre>

<p>... 略 ...</p>

<pre><code>z
</code></pre>

<p>}
Browse[2]> n
debug: ret.x <- x
Browse[2]> n
debug: ret.y <- y
Browse[2]> n
debug: cl &lt;- match.call()
```</p></blockquote>

<p>除錯完畢後可用<code>undebug</code>來將中斷點移除。</p>

<h2>trace</h2>

<p>有時候只是檢視或修改變數並不夠。
<code>trace</code>函數能在除錯時插入程式碼到某個函數，
並在<code>untrace</code>後還原該函數。</p>

<p>``` rconsole str(trace)</p>

<blockquote><p>str(trace)
function (what, tracer, exit, at, print, signature, where = topenv(parent.frame()),</p>

<pre><code>edit = FALSE)  
</code></pre>

<p>```</p></blockquote>

<ul>
<li><code>what</code>: 要修改的函數名稱</li>
<li><code>tracer</code>: 要插入的函數或expression。<code>trace</code>會在<code>at</code>給的行數之前執行，或是<code>what</code>開始之前執行。</li>
<li><code>exit</code>: 當<code>what</code>結束之後執行的函數或expression</li>
<li><code>at</code>: <code>trace</code>執行的行數。</li>
</ul>


<p>其他的參數請參閱trace的說明。</p>

<p>測試一下：
<code>r trace-example-1
test_func &lt;- function() {
  a &lt;- 1
  a &lt;- 2
  a &lt;- 3
}
trace(test_func, browser, browser)
test_func()
</code></p>

<p>``` rconsole trace-example-1-output</p>

<blockquote><p>test_func()
Tracing test_func() on entry
Called from: eval(expr, envir, enclos)
Browse[1]> a
Error: object 'a' not found
Browse[1]> c
Tracing test_func() on exit
Called from: eval(expr, envir, enclos)
Browse[1]> a
[1] 3
Browse[1]> c</p>

<p>```</p></blockquote>

<p>可以看到第一次browser是在執行test_func之前，所以<code>a</code>不存在。
第二次則是離開的時候，所以<code>a</code>為<code>3</code>。</p>

<p><code>r trace-example-2
test_func &lt;- function() {
  a &lt;- 1
  a &lt;- 2
  a &lt;- 3
}
trace(test_func, quote(print(a)), at=3:4) #利用quote直接插入print(a)到程式中
body(test_func)
test_func()
</code></p>

<p>``` rconsole trace-example-2-output</p>

<blockquote><p>body(test_func)
{</p>

<pre><code>a &lt;- 1
{
    .doTrace(print(a), "step 3")
    a &lt;- 2
}
{
    .doTrace(print(a), "step 4")
    a &lt;- 3
}
</code></pre>

<p>}
test_func()
Tracing test_func() step 3
[1] 1
Tracing test_func() step 4
[1] 2</p>

<p>```</p></blockquote>

<p>搭配quote使用可以直接更改function的程式碼，好用好用！
注意at參數所代表的位置！！(讓我滿意外的)</p>

<h1>Reference</h1>

<p><a href="http://www.math.ncu.edu.tw/~chenwc/R_note/reference/debug/Rdebug.pdf">Rdebug</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rcpp-2]]></title>
    <link href="http://wush978.github.com/blog/2012/06/04/rcpp-2/"/>
    <updated>2012-06-04T13:56:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/06/04/rcpp-2</id>
    <content type="html"><![CDATA[<p>本文延續<a href="/blog/2012/02/28/rcpp/">Rcpp-1</a>。</p>

<h1>從R傳遞資料到C++</h1>

<h2>傳遞到對應的物件</h2>

<h3>Vector</h3>

<p>在R的底層之中，最基礎的資料型態就是某六種型態的vector(詳情請見下表)。
傳遞這六種資料型態的vector到C++並不難，只要宣告對應的Rcpp class以及把透過<code>.Call</code>傳遞進來的SEXP丟到Rcpp class的constructor內就好了。</p>

<p>表一：</p>

<table>
<thead>
<tr>
<th>atomic type</th>
<th>Rcpp Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>logical</td>
<td>LogicalVector</td>
</tr>
<tr>
<td>integer</td>
<td>IntegerVector</td>
</tr>
<tr>
<td>double</td>
<td>NumericVector</td>
</tr>
<tr>
<td>complex</td>
<td>ComplexVector</td>
</tr>
<tr>
<td>character</td>
<td>CharacterVector</td>
</tr>
<tr>
<td>raw</td>
<td>RawVector</td>
</tr>
</tbody>
</table>


<p>ps. 在R中，幾乎所有物件都是vector</p>

<p>以<code>integer</code>為例子:</p>

<p>``` cpp test-rcpp.cpp</p>

<h1>include &lt;Rcpp.h></h1>

<p>using namespace Rcpp;</p>

<p>RcppExport SEXP R2CppInteger(SEXP RIntegerVec);</p>

<p>SEXP R2CppInteger(SEXP r_int_vec) {</p>

<pre><code>IntegerVector int_vec(r_int_vec);
for (R_len_t i(0);i &lt; int_vec.length();i++) {
    Rprintf("%d ", int_vec[i]);
}
Rprintf("\n length: %d \n", int_vec.length());
return R_NilValue;
</code></pre>

<p>}</p>

<p>```</p>

<p>編譯後，在R底下執行</p>

<p><code>r test.R
dyn.load("test-rcpp.so")
a &lt;- 1L:10L
.Call("R2CppInteger", a)
dyn.unload("test-rcpp.so")
</code></p>

<p>就會看到輸出</p>

<pre><code>1 2 3 4 5 6 7 8 9 10 
 length: 10 
NULL
</code></pre>

<p>如果需要使用上的細節，只需要查閱<a href="http://dirk.eddelbuettel.com/code/rcpp/html/classVector.html">Rcpp Reference中關於Vector</a>的部分。</p>

<p>而Rcpp還有許多可以直接傳遞其他進階的R物件的C++物件。</p>

<h3>Matrix</h3>

<p>因為R中的matrix 或 array 物件其實就是加上dimension的vector，所以可以直接用xxxVector物件在C++內處理。
Rcpp中另外還有更類似R的matrix的xxxMatrix物件。
只是要注意，在C++裡面取出來的row或column在C++裡的型態會是<code>Rcpp::xxxMatrix::Row</code>或<code>Rcpp::xxxMatrix::Column</code>。請見以下範例：</p>

<p>``` cpp test-rcpp.cpp</p>

<h1>include &lt;Rcpp.h></h1>

<p>using namespace Rcpp;</p>

<p>RcppExport SEXP R2CppInteger(SEXP RIntegerVec);</p>

<p>SEXP R2CppInteger(SEXP r_int_mat) {</p>

<pre><code>IntegerMatrix int_mat(r_int_mat);
Rprintf("print the matrix\n");
for(int i(0);i &lt; int_mat.nrow();i++) {
    for(int j(0);j &lt; int_mat.ncol();j++) {
        Rprintf("%d ", int_mat(i, j));
    }
    Rprintf("\n");
}
Rprintf("print the first column: ");
IntegerMatrix::Column int_mat_col( int_mat(internal::NamedPlaceHolder(), 0 ) );
for(int i(0);i &lt; int_mat.nrow();i++) {
    Rprintf("%d ", int_mat_col[i]);
}
Rprintf("\n");
return R_NilValue;  
</code></pre>

<p>}
```</p>

<p>編譯之後在R底下執行
<code>r
dyn.load("test-rcpp.so")
a &lt;- matrix(1L:10L, 2, 5)
.Call("R2CppInteger", a)
dyn.unload("test-rcpp.so")
</code></p>

<p>就可以看到輸出</p>

<pre><code>print the matrix
1 3 5 7 9 
2 4 6 8 10 
print the first column: 1 2 
NULL
</code></pre>

<h3>List</h3>

<p>list物件在R也是非常的重要，而且和上述的vector型態已經不一樣了。
在R中，一個vector內的資料一定只能是相同的atomic type，但是在list中就可以放不同的atomic type。
說穿了，List物件也只是R物件的vector，這從Rcpp中List的定義：<code>typedef Vector&lt;VECSXP&gt; List</code>可窺見一二。</p>

<p>``` cpp test-rcpp.cpp</p>

<h1>include &lt;Rcpp.h></h1>

<p>using namespace Rcpp;</p>

<p>RcppExport SEXP R2CppList(SEXP RList);</p>

<p>Function show("show");</p>

<p>SEXP R2CppList(SEXP RList) {</p>

<pre><code>List list(RList);
for (R_len_t i = 0;i &lt; list.size();i++) {
    show(list[i]);
} 
return R_NilValue;
</code></pre>

<p>}
```</p>

<p>ps. 這裡的Function是Rcpp中呼叫R function的方式，之後會再介紹。這裡的用途只是把傳入的東西以R中的<code>show</code>函數顯示到console上。</p>

<p>編譯之後在R底下執行
<code>r
dyn.load("test-rcpp.so")
a &lt;- list()
a[[1]] &lt;- 1L:10L
a[['a']] &lt;- paste("test", 1:10)
a[[2]] &lt;- factor(sample(1:2, 10, TRUE))
.Call("R2CppList", a)
</code></p>

<p>就可以看到：</p>

<pre><code> [1]  1  2  3  4  5  6  7  8  9 10
 [1] 2 2 1 2 2 1 2 1 1 2
Levels: 1 2
NULL
</code></pre>

<h3>data.frame</h3>

<p>data.frame 其實就只是滿足某些條件的List物件，所以是可以用List物件來做處理的。
除此之外Rcpp也提供C++物件：DataFrame給使用者。
但是目前除了提供方便的建立DataFrame物件之外，只有類似List的操作方法。在此就不提供範例了。</p>

<h2>傳遞到STL物件</h2>

<p>Rcpp可以利用<code>as&lt;&gt;</code>函數將R物件轉換成對應的STL物件
。</p>

<h1>參考資料</h1>

<ul>
<li><a href="http://cran.r-project.org/doc/manuals/R-lang.html#Vector-objects">R Language Definition</a></li>
<li><a href="http://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-quickref.pdf">Rcpp Quick Reference Guide</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R: DateTime格式的心得]]></title>
    <link href="http://wush978.github.com/blog/2012/02/29/rdatetime/"/>
    <updated>2012-02-29T21:53:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/02/29/rdatetime</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#overview">概述</a></li>
<li><a href="#functions">函數心得</a>

<ul>
<li>取得當前的時間

<ul>
<li><a href="#Sys.time">Sys.time</a></li>
<li><a href="#Sys.Date">Sys.Date</a></li>
</ul>
</li>
<li>時間格式間的轉換

<ul>
<li><a href="#mktime">mktime</a></li>
<li><a href="#localtime">localtime</a></li>
<li><a href="#gmtime">gmtime</a></li>
</ul>
</li>
<li>時間和字串間的轉換

<ul>
<li><a href="#strftime">strftime</a></li>
<li><a href="#strptime">strptime</a></li>
</ul>
</li>
<li><a href="#trunc">trunc</a></li>
</ul>
</li>
<li><a href="#reference">參考資料</a></li>
</ul>


<hr />

<h2 id="overview"> 概述 </h2>


<p>R中主要的時間物件為<code>POSIXct</code>和<code>POSIXlt</code>。[Date-Time Classes]第8頁內提到設計者們在設計這類物件的考量：</p>

<ul>
<li>日期格式應該由[locale]參數來決定。</li>
<li>時間應該由電腦的Time zones來決定。</li>
<li>參考資料庫標準(SQL99 ISO)中使用的時間格式<code>timestamp with time zone</code></li>
<li>考量到跨平台，使用[POSIX]</li>
</ul>


<p>[POSIX]是以<a href="Coordinated%20Universal%20Time">UTC</a>為基準，以c語言的<code>double</code>型態來儲存的時間格式，
而<code>POSIXct</code>則是代表以這種絕對座標所表示的時間。<code>POSIXlt</code>則是另一種包含timezones的格式
(lt代表local time)。其中timezone是以屬性tzone來代表的。</p>

<p>以以下的程式碼為例：
``` rout example from [Date-Time Classes]</p>

<blockquote><p>file.info(dir())[, "mtime", drop=FALSE]
data                  2012-02-29 21:18:11
<code>
在預設下，是以ISO標準格式來表示日期時間。
</code> r example from [Date-Time Classes]
file_time &lt;- file.info(dir())[, "mtime", drop=FALSE]
file_time
data                  2012-02-29 21:18:11
format(file_time, format="%x %X")
data                  2012/2/29 下午 09:18:11
```</p></blockquote>

<p>另外再列了幾個[Date-Time Classes]內的範例</p>

<h2 id="functions"> 函數心得 </h2>




<h3 id="Sys.time"> Sys.time </h3>


<p><code>r Sys.time
function ()
</code>
回傳<code>POSIXct</code>物件來表示現在的時間</p>

<h3 id="Sys.Date"> Sys.Date</h3>


<p><code>r Sys.time
function () {as.Date(as.POSIXlt(Sys.time()))}
</code>
回傳<code>Date</code>物件來表示現在的日期</p>

<h3 id="trunc"> trunc </h3>


<p><code>r trunc.POSIXt
function (x, units = c("secs", "mins", "hours", "days"), ...)
</code>
將<code>x</code>的時間格式轉換為以<code>units</code>為單位</p>

<h2 id="reference"> 參考資料 </h3>

[Date-Time Classes]: http://www.r-project.org/doc/Rnews/Rnews_2001-2.pdf
[locale]: http://en.wikipedia.org/wiki/Locale
[UTC]: http://en.wikipedia.org/wiki/Coordinated_Universal_Time

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rcpp-1]]></title>
    <link href="http://wush978.github.com/blog/2012/02/28/rcpp/"/>
    <updated>2012-02-28T15:42:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/02/28/rcpp</id>
    <content type="html"><![CDATA[<h1>Rcpp 心得 -- 簡介</h1>

<ul>
<li><a href="#overview">概述</a>

<ul>
<li><a href="#background">背景知識</a></li>
<li><a href="#introduction">介紹</a></li>
<li><a href="#install">安裝</a></li>
<li><a href="#compile">編譯</a></li>
<li><a href="#reference">參考資料</a></li>
</ul>
</li>
</ul>


<hr />

<h2 id="overview"> 概述 </h2>




<h3 id="background"> 背景知識 </h3>


<p>就我所知，要能理解Rcpp的語法，你必須先對C++這個我個人認為最難學的語言先學到某種程度才行。根據<a href="http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876">Effective C++</a>的作者Scott Meyers的看法，C++其實是下列四種程式語言的集合(難怪很難，一個打四個!!):</p>

<ul>
<li>C的特性 (指標、陣列等等)</li>
<li>物件導向</li>
<li>STL 標準函式庫</li>
<li>Template</li>
</ul>


<p>Rcpp中大量的使用了後面三種，所以如果看不習慣Rcpp的使用者，可能得先回頭把C++後面三種的語法複習一下了。</p>

<h3 id="introduction"> 介紹 </h3>


<p><a href="http://dirk.eddelbuettel.com/code/rcpp.html">Rcpp</a> 是一個整合R和C++的library。
使用過R中的<code>.Call</code>函數的人一定會對於處理R和C之間資料結構的轉換感到很煩人，而Rcpp給我的第一個印象就是他把這些重複性很高的轉換給包起來了!所以在使用Rcpp時使用者不需要再去撰寫諸如以下的程式碼:</p>

<p>``` c return a R integer vector with R API</p>

<h1>include &lt;R.h></h1>

<h1>include &lt;Rdefines.h></h1>

<p>SEXP foo()
{</p>

<pre><code>SEXP retval;
PROTECT(retval = NEW_INTEGER(2));
INTEGER_POINTER(retval)[0] = 1;
INTEGER_POINTER(retval)[1] = 2;
UNPROTECT(1);
return retval;
</code></pre>

<p>}
```</p>

<p>在Rcpp中, 透過C++的物件導向和template語法可以用下列的語法得到相同的效果：</p>

<p>``` cpp return a R integer vector with Rcpp</p>

<h1>include &lt;Rcpp.h></h1>

<p>RcppExport SEXP foo()
{</p>

<pre><code>Rcpp::IntegerVector retval(2);
retval[0] = 1;
retval[1] = 2;
return Rcpp::wrap( retval );
</code></pre>

<p>}
```</p>

<p>比較上面兩段語法後，我基於以下的理由比較喜歡Rcpp的語法:</p>

<ol>
<li><p>Rcpp的語法比較簡潔。尤其是在比較<code>INTEGER_POINTER(retval)[0]</code>和<code>retval[0]</code>，
這種在真正寫功能時最常用到的語法，我比較喜歡使用後者。雖然你也可以再宣告一個指標:<code>int* retval_ptr = INTEGER_POINTER(retval)</code>
來達到類似的效果，但是對我來說, 明明都是代表<code>retval</code>這個物件，卻需要宣告兩個變數就是彆扭。</p></li>
<li><p>Rcpp可以使用更精確的型態。我認為比起<code>SEXP</code>或<code>NEW_INTEGER</code>，
<code>IntegerVector</code>是更清楚的，而且也更簡潔。除了<code>IntegerVector</code>外，Rcpp之中也定義了許許多多的型態，
甚至連<code>Matrix</code>、<code>Robj</code>(S4 object)和<code>environment</code>都有呢!</p></li>
<li><p>在物件導向的語法中我就可以依循<b>RAII(<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a>)</b>的原則來寫code，
降低了memory leak等資源洩漏的可能，也免除了使用<code>PROTECT</code>、<code>UNPROTECT</code>的困擾。</p></li>
</ol>


<p>除了語法上吸引我之外，Rcpp還可以還可以和inline套件結合，直接在R內進行即時編譯；還可以和另一個套件sugar一起使用，再增加程式的執行效能。</p>

<h3 id="install"> 安裝 </h3>


<p>Rcpp的安裝非常簡單，和一般的R套件相同。有興趣的使用者還可以額外安裝inline或sugar來玩。
Windows的使用者請額外安裝能編譯R的工具庫: <a href="http://cran.r-project.org/bin/windows/Rtools/">Rtools</a> ，並且記得到Rcpp的目錄中不要包含空白，否則用R CMD SHLIB編譯的時候會有錯誤。</p>

<h3 id="compile"> 編譯 </h3>


<ol>
<li>使用inline，這也是最簡單的方式。以下是一個取自<a href="http://dirk.eddelbuettel.com/code/rcpp/Rcpp-FAQ.pdf">Frequently Asked Questions about Rcpp</a>的範例:</li>
</ol>


<p>``` r Compile with R package "inline"
fx &lt;- cxxfunction(signature( x = "numeric" ), '</p>

<pre><code>NumericVector xx(x);
return wrap( std::accumulate( xx.begin(), xx.end(), 0.0));',
plugin = "Rcpp")
</code></pre>

<p>res &lt;- fx( seq( 1, 10, by = 0.5 ) )
res
```</p>

<ol>
<li>使用R CMD SHLIB的話則需要調整compiler的參數。以下的範例是在bash底下執行，是透過修改環境變數的方式。</li>
</ol>


<p><code>bash Compile with R CMD SHLIB
export PKG_LIBS=$(Rscript -e "Rcpp:::LdFlags()")
export PKG_CXXFLAGS=$(Rscript -e "Rcpp::CxxFlags()")
R CMD SHLIB myfile.cpp
</code></p>

<ol>
<li>在R內呼叫Rcpp的函數<code>Rcpp:::SHLIB</code>來編譯。</li>
</ol>


<p><code>r Compile with Rcpp:::SHLIB
Rcpp:::SHLIB("mysource.cpp")
</code></p>

<p>在windows底下，方法2.我花了很久才測出來(網路上找到資料是說只要Rcpp和他的父目錄名稱有空白就會出錯)!後來我大部分是用方法1和3了。</p>

<h3 id="reference"> 參考資料 </h3>


<ul>
<li><a href="http://dirk.eddelbuettel.com/papers/Rcpp-introduction.pdf">Rcpp: Seamless R and C++ Interface</a></li>
<li><a href="http://dirk.eddelbuettel.com/code/rcpp/Rcpp-FAQ.pdf">Frequently Asked Questions about Rcpp</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
