<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | Wush筆記]]></title>
  <link href="http://wush978.github.com/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://wush978.github.com/"/>
  <updated>2012-08-21T20:49:07+08:00</updated>
  <id>http://wush978.github.com/</id>
  <author>
    <name><![CDATA[Wush978]]></name>
    <email><![CDATA[wush.978@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RcppArmadillo]]></title>
    <link href="http://wush978.github.com/blog/2012/08/21/rcpparmadillo/"/>
    <updated>2012-08-21T20:08:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/21/rcpparmadillo</id>
    <content type="html"><![CDATA[<h1>Inroduction</h1>

<p>Recently I am exploring the linear algebra features provided in <a href="http://arma.sourceforge.net/">Armadillo</a> through <a href="http://dirk.eddelbuettel.com/code/rcpp.armadillo.html">RcppArmadillo</a>.</p>

<p>Here is the note for myself.</p>

<p>Note these functions are only my understanding of these operators and methods. I didn't check the source code of Armadillo and RcppArmadillo.</p>

<h1>Feature</h1>

<h2>Matrix Multiplication</h2>

<p><code>cpp Matrix Multiplication
const arma::mat operator*(const arma::mat&amp; x, const arma::mat&amp; y);
</code></p>

<h2>Transpose</h2>

<p>``` cpp Transpose
const arma::mat arma::trans(const arma::mat&amp; x);</p>

<p>// Methods of class arma::mat
// x.t() = arma::trans(x)
const arma::mat arma::mat::t();
```</p>

<h2>Inverse</h2>

<p><code>cpp Inverse
const arma::mat arma::pinv(const arma::mat&amp; x);
</code></p>

<h2>Sum of Square</h2>

<p>``` cpp Sum of Square
inline double sumOfSquare(arma::vec&amp; x) {</p>

<pre><code>return std::inner_product(x.begin(), x.end(), x.begin(), 0.0);
</code></pre>

<p>}
```</p>

<h2>Diagonal Vector</h2>

<p><code>cpp Diagonal Vector
const arma::colvec arma::diagvec(const arma::mat&amp; x);
</code></p>

<h2>Linear Regression</h2>

<p>``` cpp Linear Regression
/<em>*
 * @param X    the explanatory variables
 * @param y    the response variable
 * @return     the vector of regression coefficients
 </em>/
const arma::colvec arma::solve(const arma::mat&amp; X, const arma::vec&amp; y);</p>

<p>// Residuals
arma::colvec residuals = y - X * coef;</p>

<p>// Residual Sum of Square
double s2 = sumOfSquare(residuals);</p>

<p>// Std of Coef.
arma::colvec sderr = arma::sqrt(s2 *</p>

<pre><code>arma::diagvec(arma::pinv(arma::trans(X)*X)));
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Proxmox &amp; R cluster]]></title>
    <link href="http://wush978.github.com/blog/2012/08/16/proxmox-and-r-cluster/"/>
    <updated>2012-08-16T11:57:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/16/proxmox-and-r-cluster</id>
    <content type="html"><![CDATA[<p>Here I'll show how to set up my parallel computing environment of R.</p>

<h1>Introduction</h1>

<p>As far as I know, the virtualization for linux with <a href="http://wiki.openvz.org/Main_Page">OpenVZ</a> does not loss too many computation efficiency.
Moreover, it provides a simple way to <em>copy</em> whole computation environment from one machine to another.
The consistency of the environment reduces the difficulty of setting MPI between machines, so I decide
to build my R cluster under Proxmox, which is an easy to use open source virtualization platform.</p>

<h1>Environment</h1>

<p>OS:</p>

<ul>
<li>Host OS: <a href="http://www.proxmox.com/">Proxmox</a>(Version 2.1-1/fb0f63a)</li>
<li>Container OS: <a href="http://www.ubuntu.com/">Ubuntu Precise</a>(Version 12.04)</li>
</ul>


<p>Software(Installed in Container OS):</p>

<ul>
<li><a href="http://www.r-project.org/">R</a>(Version 2.14.1)

<ul>
<li><a href="http://www.stats.uwo.ca/faculty/yu/Rmpi/">Rmpi</a>(Version 0.5-9)</li>
<li><a href="http://cran.r-project.org/web/packages/snow/index.html">snow</a>(Version 0.3-10)</li>
</ul>
</li>
<li><a href="http://rstudio.org/">Rstudio</a>(Version 0.96.316)</li>
<li><a href="http://packages.ubuntu.com/precise/mpich2">MPICH2</a>(Version 1.4.1)</li>
</ul>


<h1>Set up Proxmox Cluster</h1>

<h2>Install Proxmox</h2>

<p>Please see <a href="http://pve.proxmox.com/wiki/Installation">Proxmox Installation</a></p>

<h2>Set up Proxmox Cluster</h2>

<p>Please see <a href="http://pve.proxmox.com/wiki/Proxmox_VE_Cluster#Create_a_Proxmox_VE_Cluster">Create a Proxmox VE Cluster</a></p>

<h2>Create a container</h2>

<p>An easy way is to create the container under the management console of Proxmox.</p>

<p>Please download the container template from [http://wiki.openvz.org/Download/template/precreated] and put it under <code>/var/lib/vz/template/cache/</code>.</p>

<p>Here, I write small shell script (modified from <a href="https://raw.github.com/drivard/openvz-create-container-script/master/createvz.sh">Here</a>)
to create the virtual container with 6 CPUs, 2G memory and 32G disk:</p>

<p>``` sh create_vz.sh</p>

<h1>! /bin/bash</h1>

<p>VZUID="$1"
VZHOSTNAME="$2"
VZIP="$3"
VZTEMPLATE="$4"
if [[ $1 != "" &amp;&amp; $2 != "" &amp;&amp; $3 != "" &amp;&amp; $4 != "" ]]; then
  /usr/bin/pvectl create $VZUID $VZTEMPLATE --cpus 6 --disk 32 --hostname $VZHOSTNAME --memory 2048 --swap 2048 --nameserver 8.8.8.8 --password initpasswd --pool Rslaves --netif ifname=eth0,mac=$(./macgen.py),host_ifname=veth103.0,host_mac=<host_mac>,bridge=vmbr0
  /usr/bin/pvectl set $VZUID --ip_address $VZIP
else
  /bin/echo ""
  /bin/echo "./create_vz.sh <UID> <HOSTNAME> <IP> <TEMPLATE>"
  /bin/echo ""
  /bin/echo ""
  /usr/bin/pvectl list
fi
```</p>

<p>Note that the initial root password is <em>initpasswd</em> and the user need to fill <host_mac> according to the mac address of the host.(run <code>ifconfig</code> in host machine or check the setting of the container created in management console).</p>

<p>The mac address is initialized according to the following python scripts:</p>

<p>``` py macgen.py</p>

<h1>! /usr/bin/python</h1>

<h1>Filename: macgen.py</h1>

<h1>Usage: It's intended to generate MAC addresses for virtualized</h1>

<h1>systems that created by Xen, OpenVZ, Vserver etc.</h1>

<p>import random</p>

<h1>The first line is defined for specified vendor</h1>

<p>mac = [ 0x00, 0x24, 0x81,
random.randint(0x00, 0x7f),
random.randint(0x00, 0xff),
random.randint(0x00, 0xff) ]</p>

<p>print ':'.join(map(lambda x: "%02x" % x, mac))
```</p>

<p>After creating <em>create_vz.sh</em> and <em>macgen.py</em> and put them into the same directory,
run the shell command <code>./create_vz.sh 200 Rmaster 192.168.0.100 /var/lib/vz/template/cache/ubuntu-12.04-x86_64.tar.gz</code></p>

<pre><code>Creating container private area (/var/lib/vz/template/cache/ubuntu-12.04-x86_64.tar.gz)
Performing postcreate actions
CT configuration saved to /etc/pve/openvz/200.conf
Container private area was created
CT configuration saved to /etc/pve/openvz/200.conf
</code></pre>

<h1>Set up the prototype of container</h1>

<p>I will set up everything in one container and copy it to other machines in Proxmox Cluster.</p>

<p>Note that the following commands are executed in the container under root privilege.</p>

<h2>Initialize</h2>

<p>Login the virtual machine via ssh(<code>ssh root@192.168.0.100</code>) with the initial root password.</p>

<p><code>sh
locale-gen --lang en_US en_US.UTF-8
apt-get update
apt-get upgrade -y
apt-get install build-essential -y
</code></p>

<h2>Install R</h2>

<p><code>sh
apt-get install r-base -y
</code></p>

<h2>Set <em>/etc/hosts</em></h2>

<p>Here I'll set up a clusters with 3 machines:</p>

<p><code>text /etc/hosts
192.168.0.100 Rmaster
192.168.0.101 Rslave1
192.168.0.102 Rslave2
</code></p>

<h2>Set SSH</h2>

<p>Enable ssh public key authentication.</p>

<p><code>text
adduser ruser
su ruser
ssh-keygen -t dsa -N "" -f ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
exit
</code></p>

<p>Test</p>

<p><code>text
sudo -u ruser ssh ruser@localhost
</code></p>

<p>We should directly login without prompt of password.</p>

<h2>Install MPICH2</h2>

<p><code>sh
apt-get install mpich2 -y
</code></p>

<p>Check Install Result</p>

<p>Run <code>mpich2version</code></p>

<pre><code>MPICH2 Version:         1.4.1
MPICH2 Release date:    Wed Aug 24 14:40:04 CDT 2011
MPICH2 Device:          ch3:nemesis
MPICH2 configure:       --build=x86_64-linux-gnu --prefix=/usr --includedir=${prefix}/include --mandir=${prefix}/share/man --infodir=${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --libexecdir=${prefix}/lib/mpich2 --srcdir=. --disable-maintainer-mode --disable-dependency-tracking --disable-silent-rules --enable-shared --prefix=/usr --enable-fc --disable-rpath --sysconfdir=/etc/mpich2 --includedir=/usr/include/mpich2 --docdir=/usr/share/doc/mpich2 --with-hwloc-prefix=system --enable-checkpointing --with-hydra-ckpointlib=blcr
MPICH2 CC:      gcc  -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -Werror=format-security -Wall  -O2
MPICH2 CXX:     c++  -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -Werror=format-security -Wall -O2
MPICH2 F77:     gfortran  -g -O2 -O2
MPICH2 FC:      gfortran   -O2
</code></pre>

<h2>Install Rmpi with MPICH2</h2>

<p>Comment out origin setting of <code>CC</code> and <code>SHLIB_LD</code>.
Add:</p>

<p>``` text</p>

<h1>CC = ...</h1>

<p>CC = mpicc
...</p>

<h1>SHLIB_LD = ...</h1>

<p>SHLIB_LD=mpicc
```</p>

<p>Open <em>R</em> console and execute following commands to install <em>Rmpi</em> with <em>MPICH2</em>:</p>

<p><code>r install Rmpi
install.packages('Rmpi',configure.args="--with-Rmpi-type=MPICH2 --with-Rmpi-include=/usr/lib/mpich2/include --with-Rmpi-libpath=/usr/lib/mpich2/lib/ --with-mpi=/usr/include/mpich2/")
</code></p>

<p>Recover <em>/etc/R/Makeconf</em>:</p>

<p>``` text
CC = ...</p>

<h1>CC = mpicc</h1>

<p>...
SHLIB_LD = ...</p>

<h1>SHLIB_LD=mpicc</h1>

<p>```</p>

<p>Modify <em>/usr/local/lib/R/site-library/Rmpi/Rslaves.sh</em> line 17:</p>

<p>``` text /usr/local/lib/R/site-library/Rmpi/Rslaves.sh
...</p>

<pre><code>    $R_HOME/bin/R --no-init-file --slave --no-save &lt; $1 &gt; /tmp/$hn.$2.$$.log 2&gt;&amp;1
</code></pre>

<p>...
```</p>

<p>Note that without modification of <em>/usr/local/lib/R/site-library/Rmpi/Rslaves.sh</em> will produce <em>Permission denied</em> during <code>mpi.spawn.Rslaves</code>.</p>

<h2>Install snow</h2>

<p>Install <em>snow</em></p>

<p><code>r insatll snow
install.packages("snow")
</code></p>

<h1>Spread Prototype</h1>

<p>In this section, the commands are executed in host OS (Proxmox) if there is no further explanation.</p>

<h2>Shutdown the prototype of container</h2>

<p>Before deploying the prototype of container to other machines, I suggest
to shutdown the prototype.</p>

<p><code>sh Under container
init 0
</code></p>

<h2>Backup the Snapshot of the container</h2>

<p>run <code>vzdump -dumpdir . 200</code></p>

<p><code>
INFO: starting new backup job: vzdump 200 --dumpdir .
INFO: Starting Backup of VM 200 (openvz)
INFO: CTID 200 exist unmounted down
INFO: status = stopped
INFO: backup mode: stop
INFO: ionice priority: 7
INFO: creating archive './vzdump-openvz-200-2012_08_16-13_53_23.tar'
INFO: Total bytes written: 960901120 (917MiB, 716MiB/s)
INFO: archive file size: 916MB
INFO: delete old backup './vzdump-openvz-200-2012_08_16-13_33_40.tar'
INFO: Finished Backup of VM 200 (00:00:02)
INFO: Backup job finished successfully
</code></p>

<p>The Proxmox will dump the environment of the prototype container to one file whose size is about 1G.
Note that <em>200</em> is the <em>uid</em> of the prototype.</p>

<h2>Copy the prototype</h2>

<p>I spread the prototype with the following shell scripts.</p>

<p>Please remember to modify the <host_mac> or other settings to fit your own environment.</p>

<p>``` sh spread_vz.sh</p>

<h1>! /bin/bash</h1>

<p>VZUID="$1"
VZHOSTNAME="$2"
VZIP="$3"
VZDUMP="$4"
if [[ $1 != "" &amp;&amp; $2 != "" &amp;&amp; $3 != "" &amp;&amp; $4 != "" ]]; then
  vzrestore $VZDUMP $VZUID
  pvectl set $VZUID --ip_address $VZIP --netif ifname=eth0,mac=$(./macgen.py),host_ifname=veth$VZUID.0,host_mac=<host_mac>,bridge=vmbr0 --hostname $VZHOSTNAME
else
  /bin/echo ""
  /bin/echo "./spread_vz.sh <UID> <HOSTNAME> <IP> <VZDUMP>"
  /bin/echo ""
  /bin/echo ""
  /usr/bin/pvectl list
fi
```</p>

<p>run <code>./spread_vz.sh 201 Rslave1 192.168.0.101 vzdump-openvz-200-2012_08_16-13_53_23.tar</code></p>

<p><code>text
extracting archive '/root/dump/vzdump-openvz-200-2012_08_16-13_53_23.tar'
Total bytes read: 960901120 (917MiB, 470MiB/s)
restore configuration to '/etc/pve/nodes/&lt;cluster1&gt;/openvz/201.conf'
CT configuration saved to /etc/pve/openvz/201.conf
</code></p>

<p>run <code>./spread_vz.sh 202 Rslave2 192.168.0.102 vzdump-openvz-200-2012_08_16-13_53_23.tar</code> for second slave.</p>

<h2>Deploy the slave</h2>

<p>Just open the management console of Proxmox to migrate these new containers to other machines in Proxmox Cluster.</p>

<h2>Validate Environment</h2>

<ul>
<li>Start all containers.</li>
<li>Login to Rmaster as ruser.</li>
<li>Try ssh to Rslave1 and Rslave2 as ruser. It should not require password.</li>
<li>Check the content of <em>/etc/hosts</em> on all machines.</li>
<li>Create Rmpi.conf as
<code>text
Rmaster
Rslave1
Rslave2
</code></li>
<li>Create Rmpi.test.R as
<code>r Rmpi.test.R
library(Rmpi)
cl &lt;- mpi.spawn.Rslaves(nslaves=6)
mpi.close.Rslaves()
mpi.quit()
</code></li>
<li>execute <code>mpiexec -np 1 -f Rmpi.conf R --vanilla &lt; Rmpi.test.R</code>
``` text
R version 2.14.1 (2011-12-22)
Copyright (C) 2011 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-pc-linux-gnu (64-bit)</li>
</ul>


<p>R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.</p>

<p>  Natural language support but running in an English locale</p>

<p>R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.</p>

<p>Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.</p>

<blockquote><p>library(Rmpi)
cl &lt;- mpi.spawn.Rslaves(nslaves=6)</p>

<pre><code>    6 slaves are spawned successfully. 0 failed.
</code></pre>

<p>master (rank 0, comm 1) of size 7 is running on: Rmaster
slave1 (rank 1, comm 1) of size 7 is running on: Rslave1
slave2 (rank 2, comm 1) of size 7 is running on: Rslave2
slave3 (rank 3, comm 1) of size 7 is running on: Rmaster
slave4 (rank 4, comm 1) of size 7 is running on: Rslave1
slave5 (rank 5, comm 1) of size 7 is running on: Rslave2
slave6 (rank 6, comm 1) of size 7 is running on: Rmaster
mpi.close.Rslaves()
[1] 1
mpi.quit()
```</p></blockquote>

<h2>Install Rstudio Server</h2>

<p><code>sh
apt-get install libssl0.9.8 libapparmor1 apparmor-utils -y
wget http://download2.rstudio.org/rstudio-server-0.96.330-amd64.deb
dpkg -i rstudio-server-0.96.330-amd64.deb
</code></p>

<p>See <a href="http://rstudio.org/download/server">Download RStudio Server</a> for details.</p>

<h2>Set Rmpi in Rstudio Server</h2>

<h3>Configuration</h3>

<p>Create <em>/etc/Rmpi.conf</em></p>

<p><code>text /etc/Rmpi.conf
Rmaster
Rslave1
Rslave2
</code></p>

<p>Create <em>/usr/lib/rstudio-server/bin/rsession-mpiexec.sh</em>:</p>

<p>``` sh /usr/lib/rstudio-server/bin/rsession-mpiexec.sh</p>

<h1>! /bin/bash</h1>

<p>mpiexec -np 1 -f /etc/Rmpi.conf -errfile-pattern /tmp/mpiexec.error.log /usr/lib/rstudio-server/bin/rsession "$@"
```</p>

<p>Modify the privilege:</p>

<p><code>sh
chmod u+x /usr/lib/rstudio-server/bin/rsession-mpiexec.sh
chmod g+x /usr/lib/rstudio-server/bin/rsession-mpiexec.sh
chmod o+x /usr/lib/rstudio-server/bin/rsession-mpiexec.sh
</code></p>

<p>Create or modify <em>/etc/rstudio/rserver.conf</em>:</p>

<p>``` text
rsession-path=/usr/lib/rstudio-server/bin/rsession-mpiexec.sh</p>

<h1>rsession-path=/usr/lib/rstudio-server/bin/rsession</h1>

<p>```</p>

<p>Modify <em>/etc/apparmor.d/rstudio-server</em>:</p>

<p><code>text rstudio-server
  #/usr/lib/rstudio-server/bin/rsession ux,
  /usr/lib/rstudio-server/bin/rsession-mpiexec.sh ux,
</code></p>

<p>Restart Rstudio Server or restart the Rmaster</p>

<p><code>sh
rstudio-server restart
</code></p>

<h3>Testing with <em>Rmpi</em></h3>

<p>Login into web interface of Rstudio and execute</p>

<p><code>r
library(Rmpi)
cl &lt;- mpi.spawn.Rslaves(nslaves=6)
mpi.close.Rslaves()
mpi.quit()
</code></p>

<p>You should see the slaves are spawned in different container/machines.</p>

<h3>Testing with <em>snow</em></h3>

<p>Login into web interface of Rstudio and execute</p>

<p><code>r
library(snow)
cl &lt;- makeMPIcluster(count = 18)
unlist(clusterEvalQ(cl, system('hostname',intern=TRUE)))
stopCluster(cl)
</code></p>

<p>You should see the hostname of slaves.</p>

<h1>Trouble Shooting:</h1>

<ul>
<li>Check the network environment

<ul>
<li>Is the <em>/etc/hosts</em> correct?</li>
<li>Can <em>ruser</em> ssh to slaves and masters without password prompt?</li>
</ul>
</li>
<li>Check logs:

<ul>
<li>the system log (/var/log/syslog)</li>
<li>mpiexec error log (/tmp/mpiexec.error.log) which is set in <em>/usr/lib/rstudio-server/bin/rsession-mpiexec.sh</em></li>
</ul>
</li>
</ul>


<p>Good Luck!</p>

<h1>Reference</h1>

<ul>
<li><a href="http://sealmemory.blogspot.tw/2012/05/ubuntu-1204-openmpi-cluster.html">海豹雜記: 使用 Ubuntu Linux 12.04 與 OpenMPI 架設 Cluster</a></li>
<li><a href="http://webappl.blogspot.tw/2012/01/install-rmpi-with-mpich2-environment.html">Web Application: Install Rmpi with MPICH2 environment</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R closure]]></title>
    <link href="http://wush978.github.com/blog/2012/08/14/r-closure/"/>
    <updated>2012-08-14T22:27:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/14/r-closure</id>
    <content type="html"><![CDATA[<p>R 中<em>function</em>也可以是一種物件型態，或稱做叫作<em>closure</em>:</p>

<p>``` rconsole</p>

<blockquote><p>typeof(rnorm)
[1] "closure"
```</p></blockquote>

<p>要比較兩個function物件，則可透過<code>body</code>這個函數：</p>

<p>``` rconsole</p>

<blockquote><p>body(rnorm) == body(rexp)
[1] FALSE
body(rnorm) == body(temp)
[1] TRUE
```</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling R code]]></title>
    <link href="http://wush978.github.com/blog/2012/06/14/profiling-r-code/"/>
    <updated>2012-06-14T23:29:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/06/14/profiling-r-code</id>
    <content type="html"><![CDATA[<h1>簡介</h1>

<p>Profiling的意思就是去測量程式中每個函數的執行時間。
根據經驗法則，通常有80%的執行時間耗費在20%的程式碼中！
所以若有提昇執行效能的需求，第一步就是找出跑得慢得程式碼(bottlenecks)，再針對慢得程式碼去做優化。</p>

<h1>介紹</h1>

<p>ps. 以下的程式碼取自<a href="http://www.math.ncu.edu.tw/~chenwc/R_note/reference/debug/Rdebug.pdf">Rdebug</a></p>

<p>考慮以下三個函數：</p>

<p>``` r fun1.R
fun1 &lt;- function(x) {</p>

<pre><code>res &lt;- NULL
n &lt;- nrow(x)
for(i in 1:n) {
    if (!any(is.na(x[i,]))) {
        res &lt;- rbind(res, x[i,])
    }
}
res
</code></pre>

<p>}
```</p>

<p>``` r fun2.R
fun2 &lt;- function(x) {</p>

<pre><code>n &lt;- nrow(x)
res &lt;- matrix(0, n, ncol(x))
k &lt;- 1
for(i in 1:n) {
    if (!any(is.na(x[i,]))) {
        res[k,] &lt;- x[i,]
        k &lt;- k + 1
    }
}
res[1:(k-1),]
</code></pre>

<p>}
```</p>

<p>``` r fun3.R
fun3 &lt;- function(x) {</p>

<pre><code>omit &lt;- FALSE
n &lt;- ncol(x)
for(i in 1:n) {
    omit &lt;- omit | is.na(x[,i])
}
x[!omit,]
</code></pre>

<p>}
```</p>

<p>將上述三個function分別寫成script檔案後，執行：</p>

<p>``` r Rprof-exp-1.R
source('fun1.R')
source('fun2.R')
source('fun3.R')</p>

<p>size.row &lt;- 10L<sup>5</sup>
size.col &lt;- 20L</p>

<p>x = matrix(rnorm(size.row * size.col),size.row,size.col)
x[x > 1.5] = NA
Rprof("method1.out")
fun1(x)
Rprof(NULL)
Rprof("method2.out")
fun2(x)
Rprof(NULL)
Rprof("method3.out")
fun3(x)
Rprof(NULL)
```</p>

<p>此時根目錄會有<code>method1.out</code>, <code>method2.out</code>, <code>method3.out</code>等三個檔案。</p>

<p>打開命令列，執行：</p>

<p><code>sh
R CMD Rprof method1.out
R CMD Rprof method2.out
R CMD Rprof method3.out
</code></p>

<p>以<code>R CMD Rprof method1.out</code>的結果為例：</p>

<pre><code>Each sample represents 0.02 seconds.
Total run time: 168.98 seconds.

Total seconds: time spent in function and callees.
Self seconds: time spent in function alone.

   %       total       %        self
 total    seconds     self    seconds    name
 100.0    168.98       0.4      0.74     fun1
  99.4    167.98      99.4    167.98     rbind
   0.1      0.20       0.1      0.20     any
   0.0      0.04       0.0      0.04     is.na
   0.0      0.02       0.0      0.02     !


   %        self       %      total
  self    seconds    total   seconds    name
  99.4    167.98      99.4    167.98     rbind
   0.4      0.74     100.0    168.98     fun1
   0.1      0.20       0.1      0.20     any
   0.0      0.04       0.0      0.04     is.na
   0.0      0.02       0.0      0.02     !
</code></pre>

<p>這份報告共有兩個表格：</p>

<ul>
<li>表格一：

<ul>
<li><code>fun1</code>(進入到退出之間)總共花了168.98秒，佔總時間的100%，但是本身(扣除可以分割的部份)只花了0.74秒，佔0.4%</li>
<li><code>rbind</code>(進去到退出之間)花了167.98秒，佔總時間的99.4%，但是本身花了167.98秒，佔整體的99.4%</li>
</ul>
</li>
<li>表格二則和表格一類似，只是表格一是依照進入和退出間所佔的時間來排序，而表格二是依照本身的執行時間來排序。</li>
</ul>


<p>由此可知，我們只要能夠針對表格二的前面數列的函數進行優化，就可以大幅度改進程式效能。</p>

<p>接下來看<code>R CMD Rprof method2.out</code>的結果：</p>

<pre><code>Each sample represents 0.02 seconds.
Total run time: 0.58 seconds.

Total seconds: time spent in function and callees.
Self seconds: time spent in function alone.

   %       total       %        self
 total    seconds     self    seconds    name
 100.0      0.58      69.0      0.40     fun2
  13.8      0.08      13.8      0.08     any
  10.3      0.06      10.3      0.06     is.na
   3.4      0.02       3.4      0.02     !
   3.4      0.02       3.4      0.02     matrix


   %        self       %      total
  self    seconds    total   seconds    name
  69.0      0.40     100.0      0.58     fun2
  13.8      0.08      13.8      0.08     any
  10.3      0.06      10.3      0.06     is.na
   3.4      0.02       3.4      0.02     !
   3.4      0.02       3.4      0.02     matrix
</code></pre>

<p>這裡使用<code>matrix</code>來取代<code>rbind</code>之後，剩下效能的瓶頸就落在<code>any</code>上。
所以<code>fun3</code>更進一步的不使用<code>any</code>，得到：</p>

<pre><code>Each sample represents 0.02 seconds.
Total run time: 0.12 seconds.

Total seconds: time spent in function and callee
Self seconds: time spent in function alone.

   %       total       %        self
 total    seconds     self    seconds    name
 100.0      0.12      16.7      0.02     fun3
  66.7      0.08      66.7      0.08     |
  16.7      0.02      16.7      0.02     is.na


   %        self       %      total
  self    seconds    total   seconds    name
  66.7      0.08      66.7      0.08     |
  16.7      0.02     100.0      0.12     fun3
  16.7      0.02      16.7      0.02     is.na
</code></pre>

<p>可以看到效能又好了近5倍(0.12 : 0.58)！</p>

<h1>參考資料</h1>

<ul>
<li><a href="http://www.math.ncu.edu.tw/~chenwc/R_note/reference/debug/Rdebug.pdf">Rdebug</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R debug]]></title>
    <link href="http://wush978.github.com/blog/2012/06/14/r-debug/"/>
    <updated>2012-06-14T01:11:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/06/14/r-debug</id>
    <content type="html"><![CDATA[<h1>簡介</h1>

<p>很少人能夠第一次寫程式就能寫對，就連最專業的程式設計師也會花大把大把的時間在除錯。
所以熟悉除錯的工具也是能夠顯著的提昇寫程式的效率。</p>

<p>其實作者我在寫這篇文章之前也完全沒用過除錯工具！想到又能提昇自己的coding效率又讓我熊熊的燃燒起來！！</p>

<h1>除錯函數</h1>

<p>R 提供了以下的除錯功能:</p>

<ul>
<li><code>traceback</code></li>
<li><code>browser</code></li>
<li><code>debug</code></li>
<li><code>trace</code></li>
</ul>


<p>就讓我來一個個探索吧！</p>

<h2>traceback</h2>

<p>所謂的traceback功能主要的目的，是找出錯誤發生時最後執行的函數：</p>

<p>``` r traceback-example-1
fail_func1 &lt;- function(size) {</p>

<pre><code>b &lt;- 5
b &lt;- b + size
b &lt;- b * 2
b &lt;- b^2
b
</code></pre>

<p>}
fail_func2 &lt;- function(size) {</p>

<pre><code>b &lt;- fail_func1(size)
a &lt;- sample(0:1,size,FALSE)
a
</code></pre>

<p>}
fail_func2(12)
traceback()
fail_func2('test')
traceback()
```</p>

<p>運行結果：</p>

<p>``` rconsole traceback-example-1-output</p>

<blockquote><p>fail_func2(12)
Error in sample(0:1, size, FALSE) :
  cannot take a sample larger than the population when 'replace = FALSE'
traceback()
2: sample(0:1, size, FALSE) at #3
1: fail_func2(12)
fail_func2('test')
Error in b + size : non-numeric argument to binary operator
traceback()
2: fail_func1(size) at #2
1: fail_func2("test")</p>

<p>```</p></blockquote>

<p>可以看出traceback確實的找出最後一個丟出錯誤的函數。</p>

<h2>browser</h2>

<p>traceback只能指出錯誤的發生處，並不能幫助使用者找出程式的錯誤。
接下來的<code>browser</code>指令則提供互動式的除錯功能：</p>

<ul>
<li>暫停程式碼的執行</li>
<li>讓使用者能察看某個時間點的變數狀態，甚至是修改變數狀態。此時以下的指令變成有特殊意義：

<ul>
<li><code>c</code> 讓程式繼續進行</li>
<li><code>n</code> 執行下一行</li>
<li><code>Q</code> 中斷</li>
</ul>
</li>
<li>繼續執行</li>
</ul>


<p>ps. 如果在中斷期間要查詢名稱為<code>c</code>、<code>n</code>、<code>Q</code>的變數內容，請用<code>print</code>指令。
但是我個人是認為不應該把變數取這類名稱！！</p>

<p>如果運行以下的指令：</p>

<p><code>r browser-example-1
global_env &lt;- 1
fail_func1 &lt;- function(size) {
  fail_func1_env &lt;- 5
  browser()
  fail_func1_env &lt;- 6
  fail_func1_env &lt;- 7
  fail_func1_env
}
fail_func2 &lt;- function(size) {
  fail_func2_env &lt;- 1
  b &lt;- fail_func1(size)
  a &lt;- sample(0:1,size,FALSE)
  a
}
fail_func2(12)
</code></p>

<p>應該會看到類似以下的結果：</p>

<p>``` rconsole browser-example-1-output</p>

<blockquote><p>fail_func2(12)
Called from: fail_func1(size)
Browse[1]> global_env
[1] 1
Browse[1]> fail_func1_env
[1] 5
Browse[1]> fail_func2_env
Error: object 'fail_func2_env' not found
Browse[1]> size
[1] 12
Browse[1]> n
debug at #4: fail_func1_env <- 6
Browse[2]> fail_func1_env
[1] 5
Browse[2]> n
debug at #5: fail_func1_env <- 7
Browse[2]> fail_func1_env
[1] 6
Browse[2]> n
debug at #6: fail_func1_env
Browse[2]> fail_func1_env
[1] 7
```</p></blockquote>

<p>在程式跑到<code>browser</code>時就暫停了。
因為<code>browser</code>是插入在<code>fail_func1</code>的第二行，所以變數應該和該時間點相同，
值得注意的是此時也只能存取該function environment內的變數</p>

<h2>debug</h2>

<p>我們可以把上一節的<code>browser</code>視為一種<em>中斷點</em>，
而<code>debug</code>函數則可以幫一個函數的每一行加入中斷點。
在對內建函數除錯的時候非常有用：</p>

<p><code>r debug-example-1
debug(lm)
lm(Sepal.Length~Species,iris)
</code></p>

<p>``` rconsole debug-example-1-output</p>

<blockquote><p>lm(Sepal.Length~Species,iris)
debugging in: lm(Sepal.Length ~ Species, iris)
debug: {</p>

<pre><code>ret.x &lt;- x
ret.y &lt;- y
</code></pre>

<p>... 略 ...</p>

<pre><code>z
</code></pre>

<p>}
Browse[2]> n
debug: ret.x <- x
Browse[2]> n
debug: ret.y <- y
Browse[2]> n
debug: cl &lt;- match.call()
```</p></blockquote>

<p>除錯完畢後可用<code>undebug</code>來將中斷點移除。</p>

<h2>trace</h2>

<p>有時候只是檢視或修改變數並不夠。
<code>trace</code>函數能在除錯時插入程式碼到某個函數，
並在<code>untrace</code>後還原該函數。</p>

<p>``` rconsole str(trace)</p>

<blockquote><p>str(trace)
function (what, tracer, exit, at, print, signature, where = topenv(parent.frame()),</p>

<pre><code>edit = FALSE)  
</code></pre>

<p>```</p></blockquote>

<ul>
<li><code>what</code>: 要修改的函數名稱</li>
<li><code>tracer</code>: 要插入的函數或expression。<code>trace</code>會在<code>at</code>給的行數之前執行，或是<code>what</code>開始之前執行。</li>
<li><code>exit</code>: 當<code>what</code>結束之後執行的函數或expression</li>
<li><code>at</code>: <code>trace</code>執行的行數。</li>
</ul>


<p>其他的參數請參閱trace的說明。</p>

<p>測試一下：
<code>r trace-example-1
test_func &lt;- function() {
  a &lt;- 1
  a &lt;- 2
  a &lt;- 3
}
trace(test_func, browser, browser)
test_func()
</code></p>

<p>``` rconsole trace-example-1-output</p>

<blockquote><p>test_func()
Tracing test_func() on entry
Called from: eval(expr, envir, enclos)
Browse[1]> a
Error: object 'a' not found
Browse[1]> c
Tracing test_func() on exit
Called from: eval(expr, envir, enclos)
Browse[1]> a
[1] 3
Browse[1]> c</p>

<p>```</p></blockquote>

<p>可以看到第一次browser是在執行test_func之前，所以<code>a</code>不存在。
第二次則是離開的時候，所以<code>a</code>為<code>3</code>。</p>

<p><code>r trace-example-2
test_func &lt;- function() {
  a &lt;- 1
  a &lt;- 2
  a &lt;- 3
}
trace(test_func, quote(print(a)), at=3:4) #利用quote直接插入print(a)到程式中
body(test_func)
test_func()
</code></p>

<p>``` rconsole trace-example-2-output</p>

<blockquote><p>body(test_func)
{</p>

<pre><code>a &lt;- 1
{
    .doTrace(print(a), "step 3")
    a &lt;- 2
}
{
    .doTrace(print(a), "step 4")
    a &lt;- 3
}
</code></pre>

<p>}
test_func()
Tracing test_func() step 3
[1] 1
Tracing test_func() step 4
[1] 2</p>

<p>```</p></blockquote>

<p>搭配quote使用可以直接更改function的程式碼，好用好用！
注意at參數所代表的位置！！(讓我滿意外的)</p>

<h1>Reference</h1>

<p><a href="http://www.math.ncu.edu.tw/~chenwc/R_note/reference/debug/Rdebug.pdf">Rdebug</a></p>
]]></content>
  </entry>
  
</feed>
