<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | Wush筆記]]></title>
  <link href="http://wush978.github.com/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://wush978.github.com/"/>
  <updated>2012-08-30T13:48:04+08:00</updated>
  <id>http://wush978.github.com/</id>
  <author>
    <name><![CDATA[Wush978]]></name>
    <email><![CDATA[wush.978@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Benchmark of Saving and Loading R Objects]]></title>
    <link href="http://wush978.github.com/blog/2012/08/30/benchmark-of-saving-and-loading-r-objects/"/>
    <updated>2012-08-30T12:48:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/30/benchmark-of-saving-and-loading-r-objects</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>To compare the speed of saving and loading R objects to and from MongoDB
with or without serialization.</p>

<h1>Environment</h1>

<ul>
<li>OpenVZ with Ubuntu 12.04, i7-2600 CPU @ 3.4GHz, 2 processors, 4G RAM</li>
<li>Local MongoDB</li>
<li>Local PostgreSQL</li>
<li>R 1.14.1</li>
<li>rmongodb 1.0.3</li>
<li>RPostgreSQL 0.3-2</li>
</ul>


<h1>Initialize</h1>

<p><code>sh
sudo apt-get install mongodb
</code></p>

<h2>R</h2>

<p><code>sh install libpq-dev
sudo apt-get install libpq-dev
</code></p>

<p><code>r install R packages
install.packages("rmongodb")
install.packages("RPostgreSQL")
</code></p>

<h1>Benchmark</h1>

<p>```r Test saving object serialized or not
{ # loading package
  library(rmongodb)
  mongo &lt;- mongo.create()
  if (!mongo.is.connected(mongo)) {</p>

<pre><code>stop("disconnected")
</code></pre>

<p>  }
}</p>

<p>save1 &lt;- function(a) {
  for(i in 1:repeat.time) {</p>

<pre><code>b &lt;- mongo.bson.from.list(list(Rdata = a))  
mongo.insert(mongo, "test.save1", b)
</code></pre>

<p>  }
}</p>

<p>load1 &lt;- function() {
  result &lt;- list()
  length(result) &lt;- repeat.time
  cursor &lt;- mongo.find(mongo, "test.save1")
  index &lt;- 1
  while(mongo.cursor.next(cursor)) {</p>

<pre><code>result[[index]] &lt;- mongo.bson.to.list(mongo.cursor.value(cursor))
index &lt;- index + 1
</code></pre>

<p>  }
  result
}</p>

<p>save2 &lt;- function(a) {
  for(i in 1:repeat.time) {</p>

<pre><code>buf &lt;- mongo.bson.buffer.create()
mongo.bson.buffer.append(buf, "Rdata", serialize(a, NULL, FALSE))
mongo.insert(mongo, "test.save2", mongo.bson.from.buffer(buf))
</code></pre>

<p>  }
}</p>

<p>load2 &lt;- function() {
  result &lt;- list()
  length(result) &lt;- repeat.time
  cursor &lt;- mongo.find(mongo, "test.save2")
  index &lt;- 1
  while(mongo.cursor.next(cursor)) {</p>

<pre><code>result[[index]] &lt;- unserialize(mongo.bson.value(mongo.cursor.value(cursor), "Rdata"))
index &lt;- index + 1
</code></pre>

<p>  }
  result
}</p>

<p>repeat.time &lt;- 1000
mongo.drop.database(mongo, "test")
a &lt;- matrix(rnorm(100<sup>2),</sup> 100, 100)
system.time({ #direct way
  print("directly save and load")
  save1(a)
  a.result &lt;- load1()
})
system.time({ #serialized way
  print("serialized before save and load")
  save2(a)
  a.result2 &lt;- load2()
})
```</p>

<p>I tested many times and notice that the results are very unstable, and
I guess that the serialized way is faster a little bit.</p>

<p>I paste some results here:</p>

<p>```
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.226   0.083   4.221
[1] "serialized before save and load"
   user  system elapsed
  0.746   0.095   3.578
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.227   0.090   3.981
[1] "serialized before save and load"
   user  system elapsed
  0.771   0.106   3.327
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.232   0.104   3.808
[1] "serialized before save and load"
   user  system elapsed
  0.760   0.110   3.289
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.303   0.078   3.827
[1] "serialized before save and load"
   user  system elapsed
  0.763   0.109   3.413
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.237   0.089   3.834
[1] "serialized before save and load"
   user  system elapsed
  0.773   0.091   3.458
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.247   0.114   3.970
[1] "serialized before save and load"
   user  system elapsed
  0.781   0.110   3.738
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.331   0.142   4.329
[1] "serialized before save and load"
   user  system elapsed
  0.753   0.098   3.202
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.217   0.090   3.766
[1] "serialized before save and load"
   user  system elapsed
  0.737   0.097   5.339
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.231   0.103   3.875
[1] "serialized before save and load"
   user  system elapsed
  0.751   0.105   3.377
rmongodb package (mongo-r-driver) loaded
Use 'help("mongo")' to get started.</p>

<p>[1] TRUE
[1] "directly save and load"
   user  system elapsed
  1.202   0.085   6.935
[1] "serialized before save and load"
   user  system elapsed
  0.752   0.082   3.996
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RcppArmadillo]]></title>
    <link href="http://wush978.github.com/blog/2012/08/21/rcpparmadillo/"/>
    <updated>2012-08-21T20:08:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/21/rcpparmadillo</id>
    <content type="html"><![CDATA[<h1>Inroduction</h1>

<p>Recently I am exploring the linear algebra features provided in <a href="http://arma.sourceforge.net/">Armadillo</a> through <a href="http://dirk.eddelbuettel.com/code/rcpp.armadillo.html">RcppArmadillo</a>.</p>

<p>Here is the note for myself.</p>

<p>Note these functions are only my understanding of these operators and methods. I didn't check the source code of Armadillo and RcppArmadillo.</p>

<h1>Basic Elements and Methods</h1>

<p>``` cpp mat
arma::mat a(5, 5); // Initialize a 5 x 5 matrix.</p>

<p>a.fill(0); // fill it with 0
a.n_rows;    //!&lt; number of rows in the matrix (read-only)
a.n_cols;    //!&lt; number of columns in the matrix (read-only)
a.n_elem;    //!&lt; number of elements in the matrix (read-only)
a.vec_state; //!&lt; 0: matrix layout; 1: column vector layout; 2: row vector layout
a.mem;       //!&lt; pointer to memory used by the matrix (memory is read-only)</p>

<p>a.min();
a.max();
```</p>

<h1>Feature</h1>

<h2>Matrix Multiplication</h2>

<p><code>cpp Matrix Multiplication
const arma::mat operator*(const arma::mat&amp; x, const arma::mat&amp; y);
</code></p>

<h2>Transpose</h2>

<p>``` cpp Transpose
const arma::mat arma::trans(const arma::mat&amp; x);</p>

<p>// Methods of class arma::mat
// x.t() = arma::trans(x)
const arma::mat arma::mat::t();
```</p>

<h2>Inverse</h2>

<p><code>cpp Inverse
const arma::mat arma::pinv(const arma::mat&amp; x);
</code></p>

<h2>Sum of Square</h2>

<p>``` cpp Sum of Square
inline double sumOfSquare(arma::vec&amp; x) {</p>

<pre><code>return std::inner_product(x.begin(), x.end(), x.begin(), 0.0);
</code></pre>

<p>}
```</p>

<h2>Diagonal Vector</h2>

<p><code>cpp Diagonal Vector
const arma::colvec arma::diagvec(const arma::mat&amp; x);
</code></p>

<h2>Linear Regression</h2>

<p>``` cpp Linear Regression
/<em>*
 * @param X    the explanatory variables
 * @param y    the response variable
 * @return     the vector of regression coefficients
 </em>/
const arma::colvec arma::solve(const arma::mat&amp; X, const arma::vec&amp; y);</p>

<p>// Residuals
arma::colvec residuals = y - X * coef;</p>

<p>// Residual Sum of Square
double s2 = sumOfSquare(residuals);</p>

<p>// Std of Coef.
arma::colvec sderr = arma::sqrt(s2 *</p>

<pre><code>arma::diagvec(arma::pinv(arma::trans(X)*X)));
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Proxmox &amp; R cluster]]></title>
    <link href="http://wush978.github.com/blog/2012/08/16/proxmox-and-r-cluster/"/>
    <updated>2012-08-16T11:57:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/16/proxmox-and-r-cluster</id>
    <content type="html"><![CDATA[<p>Here I'll show how to set up my parallel computing environment of R.</p>

<h1>Introduction</h1>

<p>As far as I know, the virtualization for linux with <a href="http://wiki.openvz.org/Main_Page">OpenVZ</a> does not loss too many computation efficiency.
Moreover, it provides a simple way to <em>copy</em> whole computation environment from one machine to another.
The consistency of the environment reduces the difficulty of setting MPI between machines, so I decide
to build my R cluster under Proxmox, which is an easy to use open source virtualization platform.</p>

<h1>Environment</h1>

<p>OS:</p>

<ul>
<li>Host OS: <a href="http://www.proxmox.com/">Proxmox</a>(Version 2.1-1/fb0f63a)</li>
<li>Container OS: <a href="http://www.ubuntu.com/">Ubuntu Precise</a>(Version 12.04)</li>
</ul>


<p>Software(Installed in Container OS):</p>

<ul>
<li><a href="http://www.r-project.org/">R</a>(Version 2.14.1)

<ul>
<li><a href="http://www.stats.uwo.ca/faculty/yu/Rmpi/">Rmpi</a>(Version 0.5-9)</li>
<li><a href="http://cran.r-project.org/web/packages/snow/index.html">snow</a>(Version 0.3-10)</li>
</ul>
</li>
<li><a href="http://rstudio.org/">Rstudio</a>(Version 0.96.316)</li>
<li><a href="http://packages.ubuntu.com/precise/mpich2">MPICH2</a>(Version 1.4.1)</li>
</ul>


<h1>Set up Proxmox Cluster</h1>

<h2>Install Proxmox</h2>

<p>Please see <a href="http://pve.proxmox.com/wiki/Installation">Proxmox Installation</a></p>

<h2>Set up Proxmox Cluster</h2>

<p>Please see <a href="http://pve.proxmox.com/wiki/Proxmox_VE_Cluster#Create_a_Proxmox_VE_Cluster">Create a Proxmox VE Cluster</a></p>

<h2>Create a container</h2>

<p>An easy way is to create the container under the management console of Proxmox.</p>

<p>Please download the container template from [http://wiki.openvz.org/Download/template/precreated] and put it under <code>/var/lib/vz/template/cache/</code>.</p>

<p>Here, I write small shell script (modified from <a href="https://raw.github.com/drivard/openvz-create-container-script/master/createvz.sh">Here</a>)
to create the virtual container with 6 CPUs, 2G memory and 32G disk:</p>

<p>``` sh create_vz.sh</p>

<h1>! /bin/bash</h1>

<p>VZUID="$1"
VZHOSTNAME="$2"
VZIP="$3"
VZTEMPLATE="$4"
if [[ $1 != "" &amp;&amp; $2 != "" &amp;&amp; $3 != "" &amp;&amp; $4 != "" ]]; then
  /usr/bin/pvectl create $VZUID $VZTEMPLATE --cpus 6 --disk 32 --hostname $VZHOSTNAME --memory 2048 --swap 2048 --nameserver 8.8.8.8 --password initpasswd --pool Rslaves --netif ifname=eth0,mac=$(./macgen.py),host_ifname=veth103.0,host_mac=<host_mac>,bridge=vmbr0
  /usr/bin/pvectl set $VZUID --ip_address $VZIP
else
  /bin/echo ""
  /bin/echo "./create_vz.sh <UID> <HOSTNAME> <IP> <TEMPLATE>"
  /bin/echo ""
  /bin/echo ""
  /usr/bin/pvectl list
fi
```</p>

<p>Note that the initial root password is <em>initpasswd</em> and the user need to fill <host_mac> according to the mac address of the host.(run <code>ifconfig</code> in host machine or check the setting of the container created in management console).</p>

<p>The mac address is initialized according to the following python scripts:</p>

<p>``` py macgen.py</p>

<h1>! /usr/bin/python</h1>

<h1>Filename: macgen.py</h1>

<h1>Usage: It's intended to generate MAC addresses for virtualized</h1>

<h1>systems that created by Xen, OpenVZ, Vserver etc.</h1>

<p>import random</p>

<h1>The first line is defined for specified vendor</h1>

<p>mac = [ 0x00, 0x24, 0x81,
random.randint(0x00, 0x7f),
random.randint(0x00, 0xff),
random.randint(0x00, 0xff) ]</p>

<p>print ':'.join(map(lambda x: "%02x" % x, mac))
```</p>

<p>After creating <em>create_vz.sh</em> and <em>macgen.py</em> and put them into the same directory,
run the shell command <code>./create_vz.sh 200 Rmaster 192.168.0.100 /var/lib/vz/template/cache/ubuntu-12.04-x86_64.tar.gz</code></p>

<pre><code>Creating container private area (/var/lib/vz/template/cache/ubuntu-12.04-x86_64.tar.gz)
Performing postcreate actions
CT configuration saved to /etc/pve/openvz/200.conf
Container private area was created
CT configuration saved to /etc/pve/openvz/200.conf
</code></pre>

<h1>Set up the prototype of container</h1>

<p>I will set up everything in one container and copy it to other machines in Proxmox Cluster.</p>

<p>Note that the following commands are executed in the container under root privilege.</p>

<h2>Initialize</h2>

<p>Login the virtual machine via ssh(<code>ssh root@192.168.0.100</code>) with the initial root password.</p>

<p><code>sh
locale-gen --lang en_US en_US.UTF-8
apt-get update
apt-get upgrade -y
apt-get install build-essential -y
</code></p>

<h2>Install R</h2>

<p><code>sh
apt-get install r-base -y
</code></p>

<h2>Set <em>/etc/hosts</em></h2>

<p>Here I'll set up a clusters with 3 machines:</p>

<p><code>text /etc/hosts
192.168.0.100 Rmaster
192.168.0.101 Rslave1
192.168.0.102 Rslave2
</code></p>

<h2>Set SSH</h2>

<p>Enable ssh public key authentication.</p>

<p><code>text
adduser ruser
su ruser
ssh-keygen -t dsa -N "" -f ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
exit
</code></p>

<p>Test</p>

<p><code>text
sudo -u ruser ssh ruser@localhost
</code></p>

<p>We should directly login without prompt of password.</p>

<h2>Install MPICH2</h2>

<p><code>sh
apt-get install mpich2 -y
</code></p>

<p>Check Install Result</p>

<p>Run <code>mpich2version</code></p>

<pre><code>MPICH2 Version:         1.4.1
MPICH2 Release date:    Wed Aug 24 14:40:04 CDT 2011
MPICH2 Device:          ch3:nemesis
MPICH2 configure:       --build=x86_64-linux-gnu --prefix=/usr --includedir=${prefix}/include --mandir=${prefix}/share/man --infodir=${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --libexecdir=${prefix}/lib/mpich2 --srcdir=. --disable-maintainer-mode --disable-dependency-tracking --disable-silent-rules --enable-shared --prefix=/usr --enable-fc --disable-rpath --sysconfdir=/etc/mpich2 --includedir=/usr/include/mpich2 --docdir=/usr/share/doc/mpich2 --with-hwloc-prefix=system --enable-checkpointing --with-hydra-ckpointlib=blcr
MPICH2 CC:      gcc  -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -Werror=format-security -Wall  -O2
MPICH2 CXX:     c++  -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -Werror=format-security -Wall -O2
MPICH2 F77:     gfortran  -g -O2 -O2
MPICH2 FC:      gfortran   -O2
</code></pre>

<h2>Install Rmpi with MPICH2</h2>

<p>Comment out origin setting of <code>CC</code> and <code>SHLIB_LD</code>.
Add:</p>

<p>``` text</p>

<h1>CC = ...</h1>

<p>CC = mpicc
...</p>

<h1>SHLIB_LD = ...</h1>

<p>SHLIB_LD=mpicc
```</p>

<p>Open <em>R</em> console and execute following commands to install <em>Rmpi</em> with <em>MPICH2</em>:</p>

<p><code>r install Rmpi
install.packages('Rmpi',configure.args="--with-Rmpi-type=MPICH2 --with-Rmpi-include=/usr/lib/mpich2/include --with-Rmpi-libpath=/usr/lib/mpich2/lib/ --with-mpi=/usr/include/mpich2/")
</code></p>

<p>Recover <em>/etc/R/Makeconf</em>:</p>

<p>``` text
CC = ...</p>

<h1>CC = mpicc</h1>

<p>...
SHLIB_LD = ...</p>

<h1>SHLIB_LD=mpicc</h1>

<p>```</p>

<p>Modify <em>/usr/local/lib/R/site-library/Rmpi/Rslaves.sh</em> line 17:</p>

<p>``` text /usr/local/lib/R/site-library/Rmpi/Rslaves.sh
...</p>

<pre><code>    $R_HOME/bin/R --no-init-file --slave --no-save &lt; $1 &gt; /tmp/$hn.$2.$$.log 2&gt;&amp;1
</code></pre>

<p>...
```</p>

<p>Note that without modification of <em>/usr/local/lib/R/site-library/Rmpi/Rslaves.sh</em> will produce <em>Permission denied</em> during <code>mpi.spawn.Rslaves</code>.</p>

<h2>Install snow</h2>

<p>Install <em>snow</em></p>

<p><code>r insatll snow
install.packages("snow")
</code></p>

<h1>Spread Prototype</h1>

<p>In this section, the commands are executed in host OS (Proxmox) if there is no further explanation.</p>

<h2>Shutdown the prototype of container</h2>

<p>Before deploying the prototype of container to other machines, I suggest
to shutdown the prototype.</p>

<p><code>sh Under container
init 0
</code></p>

<h2>Backup the Snapshot of the container</h2>

<p>run <code>vzdump -dumpdir . 200</code></p>

<p><code>
INFO: starting new backup job: vzdump 200 --dumpdir .
INFO: Starting Backup of VM 200 (openvz)
INFO: CTID 200 exist unmounted down
INFO: status = stopped
INFO: backup mode: stop
INFO: ionice priority: 7
INFO: creating archive './vzdump-openvz-200-2012_08_16-13_53_23.tar'
INFO: Total bytes written: 960901120 (917MiB, 716MiB/s)
INFO: archive file size: 916MB
INFO: delete old backup './vzdump-openvz-200-2012_08_16-13_33_40.tar'
INFO: Finished Backup of VM 200 (00:00:02)
INFO: Backup job finished successfully
</code></p>

<p>The Proxmox will dump the environment of the prototype container to one file whose size is about 1G.
Note that <em>200</em> is the <em>uid</em> of the prototype.</p>

<h2>Copy the prototype</h2>

<p>I spread the prototype with the following shell scripts.</p>

<p>Please remember to modify the <host_mac> or other settings to fit your own environment.</p>

<p>``` sh spread_vz.sh</p>

<h1>! /bin/bash</h1>

<p>VZUID="$1"
VZHOSTNAME="$2"
VZIP="$3"
VZDUMP="$4"
if [[ $1 != "" &amp;&amp; $2 != "" &amp;&amp; $3 != "" &amp;&amp; $4 != "" ]]; then
  vzrestore $VZDUMP $VZUID
  pvectl set $VZUID --ip_address $VZIP --netif ifname=eth0,mac=$(./macgen.py),host_ifname=veth$VZUID.0,host_mac=<host_mac>,bridge=vmbr0 --hostname $VZHOSTNAME
else
  /bin/echo ""
  /bin/echo "./spread_vz.sh <UID> <HOSTNAME> <IP> <VZDUMP>"
  /bin/echo ""
  /bin/echo ""
  /usr/bin/pvectl list
fi
```</p>

<p>run <code>./spread_vz.sh 201 Rslave1 192.168.0.101 vzdump-openvz-200-2012_08_16-13_53_23.tar</code></p>

<p><code>text
extracting archive '/root/dump/vzdump-openvz-200-2012_08_16-13_53_23.tar'
Total bytes read: 960901120 (917MiB, 470MiB/s)
restore configuration to '/etc/pve/nodes/&lt;cluster1&gt;/openvz/201.conf'
CT configuration saved to /etc/pve/openvz/201.conf
</code></p>

<p>run <code>./spread_vz.sh 202 Rslave2 192.168.0.102 vzdump-openvz-200-2012_08_16-13_53_23.tar</code> for second slave.</p>

<h2>Deploy the slave</h2>

<p>Just open the management console of Proxmox to migrate these new containers to other machines in Proxmox Cluster.</p>

<h2>Validate Environment</h2>

<ul>
<li>Start all containers.</li>
<li>Login to Rmaster as ruser.</li>
<li>Try ssh to Rslave1 and Rslave2 as ruser. It should not require password.</li>
<li>Check the content of <em>/etc/hosts</em> on all machines.</li>
<li>Create Rmpi.conf as
<code>text
Rmaster
Rslave1
Rslave2
</code></li>
<li>Create Rmpi.test.R as
<code>r Rmpi.test.R
library(Rmpi)
cl &lt;- mpi.spawn.Rslaves(nslaves=6)
mpi.close.Rslaves()
mpi.quit()
</code></li>
<li>execute <code>mpiexec -np 1 -f Rmpi.conf R --vanilla &lt; Rmpi.test.R</code>
``` text
R version 2.14.1 (2011-12-22)
Copyright (C) 2011 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-pc-linux-gnu (64-bit)</li>
</ul>


<p>R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.</p>

<p>  Natural language support but running in an English locale</p>

<p>R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.</p>

<p>Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.</p>

<blockquote><p>library(Rmpi)
cl &lt;- mpi.spawn.Rslaves(nslaves=6)</p>

<pre><code>    6 slaves are spawned successfully. 0 failed.
</code></pre>

<p>master (rank 0, comm 1) of size 7 is running on: Rmaster
slave1 (rank 1, comm 1) of size 7 is running on: Rslave1
slave2 (rank 2, comm 1) of size 7 is running on: Rslave2
slave3 (rank 3, comm 1) of size 7 is running on: Rmaster
slave4 (rank 4, comm 1) of size 7 is running on: Rslave1
slave5 (rank 5, comm 1) of size 7 is running on: Rslave2
slave6 (rank 6, comm 1) of size 7 is running on: Rmaster
mpi.close.Rslaves()
[1] 1
mpi.quit()
```</p></blockquote>

<h2>Install Rstudio Server</h2>

<p><code>sh
apt-get install libssl0.9.8 libapparmor1 apparmor-utils -y
wget http://download2.rstudio.org/rstudio-server-0.96.330-amd64.deb
dpkg -i rstudio-server-0.96.330-amd64.deb
</code></p>

<p>See <a href="http://rstudio.org/download/server">Download RStudio Server</a> for details.</p>

<h2>Set Rmpi in Rstudio Server</h2>

<h3>Configuration</h3>

<p>Create <em>/etc/Rmpi.conf</em></p>

<p><code>text /etc/Rmpi.conf
Rmaster
Rslave1
Rslave2
</code></p>

<p>Create <em>/usr/lib/rstudio-server/bin/rsession-mpiexec.sh</em>:</p>

<p>``` sh /usr/lib/rstudio-server/bin/rsession-mpiexec.sh</p>

<h1>! /bin/bash</h1>

<p>mpiexec -np 1 -f /etc/Rmpi.conf -errfile-pattern /tmp/mpiexec.error.log /usr/lib/rstudio-server/bin/rsession "$@"
```</p>

<p>Modify the privilege:</p>

<p><code>sh
chmod u+x /usr/lib/rstudio-server/bin/rsession-mpiexec.sh
chmod g+x /usr/lib/rstudio-server/bin/rsession-mpiexec.sh
chmod o+x /usr/lib/rstudio-server/bin/rsession-mpiexec.sh
</code></p>

<p>Create or modify <em>/etc/rstudio/rserver.conf</em>:</p>

<p>``` text
rsession-path=/usr/lib/rstudio-server/bin/rsession-mpiexec.sh</p>

<h1>rsession-path=/usr/lib/rstudio-server/bin/rsession</h1>

<p>```</p>

<p>Modify <em>/etc/apparmor.d/rstudio-server</em>:</p>

<p><code>text rstudio-server
  #/usr/lib/rstudio-server/bin/rsession ux,
  /usr/lib/rstudio-server/bin/rsession-mpiexec.sh ux,
</code></p>

<p>Restart Rstudio Server or restart the Rmaster</p>

<p><code>sh
rstudio-server restart
</code></p>

<h3>Testing with <em>Rmpi</em></h3>

<p>Login into web interface of Rstudio and execute</p>

<p><code>r
library(Rmpi)
cl &lt;- mpi.spawn.Rslaves(nslaves=6)
mpi.close.Rslaves()
mpi.quit()
</code></p>

<p>You should see the slaves are spawned in different container/machines.</p>

<h3>Testing with <em>snow</em></h3>

<p>Login into web interface of Rstudio and execute</p>

<p><code>r
library(snow)
cl &lt;- makeMPIcluster(count = 18)
unlist(clusterEvalQ(cl, system('hostname',intern=TRUE)))
stopCluster(cl)
</code></p>

<p>You should see the hostname of slaves.</p>

<h1>Trouble Shooting:</h1>

<ul>
<li>Check the network environment

<ul>
<li>Is the <em>/etc/hosts</em> correct?</li>
<li>Can <em>ruser</em> ssh to slaves and masters without password prompt?</li>
</ul>
</li>
<li>Check logs:

<ul>
<li>the system log (/var/log/syslog)</li>
<li>mpiexec error log (/tmp/mpiexec.error.log) which is set in <em>/usr/lib/rstudio-server/bin/rsession-mpiexec.sh</em></li>
</ul>
</li>
</ul>


<p>Good Luck!</p>

<h1>Reference</h1>

<ul>
<li><a href="http://sealmemory.blogspot.tw/2012/05/ubuntu-1204-openmpi-cluster.html">海豹雜記: 使用 Ubuntu Linux 12.04 與 OpenMPI 架設 Cluster</a></li>
<li><a href="http://webappl.blogspot.tw/2012/01/install-rmpi-with-mpich2-environment.html">Web Application: Install Rmpi with MPICH2 environment</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R closure]]></title>
    <link href="http://wush978.github.com/blog/2012/08/14/r-closure/"/>
    <updated>2012-08-14T22:27:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/08/14/r-closure</id>
    <content type="html"><![CDATA[<p>R 中<em>function</em>也可以是一種物件型態，或稱做叫作<em>closure</em>:</p>

<p>``` rconsole</p>

<blockquote><p>typeof(rnorm)
[1] "closure"
```</p></blockquote>

<p>要比較兩個function物件，則可透過<code>body</code>這個函數：</p>

<p>``` rconsole</p>

<blockquote><p>body(rnorm) == body(rexp)
[1] FALSE
body(rnorm) == body(temp)
[1] TRUE
```</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling R code]]></title>
    <link href="http://wush978.github.com/blog/2012/06/14/profiling-r-code/"/>
    <updated>2012-06-14T23:29:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/06/14/profiling-r-code</id>
    <content type="html"><![CDATA[<h1>簡介</h1>

<p>Profiling的意思就是去測量程式中每個函數的執行時間。
根據經驗法則，通常有80%的執行時間耗費在20%的程式碼中！
所以若有提昇執行效能的需求，第一步就是找出跑得慢得程式碼(bottlenecks)，再針對慢得程式碼去做優化。</p>

<h1>介紹</h1>

<p>ps. 以下的程式碼取自<a href="http://www.math.ncu.edu.tw/~chenwc/R_note/reference/debug/Rdebug.pdf">Rdebug</a></p>

<p>考慮以下三個函數：</p>

<p>``` r fun1.R
fun1 &lt;- function(x) {</p>

<pre><code>res &lt;- NULL
n &lt;- nrow(x)
for(i in 1:n) {
    if (!any(is.na(x[i,]))) {
        res &lt;- rbind(res, x[i,])
    }
}
res
</code></pre>

<p>}
```</p>

<p>``` r fun2.R
fun2 &lt;- function(x) {</p>

<pre><code>n &lt;- nrow(x)
res &lt;- matrix(0, n, ncol(x))
k &lt;- 1
for(i in 1:n) {
    if (!any(is.na(x[i,]))) {
        res[k,] &lt;- x[i,]
        k &lt;- k + 1
    }
}
res[1:(k-1),]
</code></pre>

<p>}
```</p>

<p>``` r fun3.R
fun3 &lt;- function(x) {</p>

<pre><code>omit &lt;- FALSE
n &lt;- ncol(x)
for(i in 1:n) {
    omit &lt;- omit | is.na(x[,i])
}
x[!omit,]
</code></pre>

<p>}
```</p>

<p>將上述三個function分別寫成script檔案後，執行：</p>

<p>``` r Rprof-exp-1.R
source('fun1.R')
source('fun2.R')
source('fun3.R')</p>

<p>size.row &lt;- 10L<sup>5</sup>
size.col &lt;- 20L</p>

<p>x = matrix(rnorm(size.row * size.col),size.row,size.col)
x[x > 1.5] = NA
Rprof("method1.out")
fun1(x)
Rprof(NULL)
Rprof("method2.out")
fun2(x)
Rprof(NULL)
Rprof("method3.out")
fun3(x)
Rprof(NULL)
```</p>

<p>此時根目錄會有<code>method1.out</code>, <code>method2.out</code>, <code>method3.out</code>等三個檔案。</p>

<p>打開命令列，執行：</p>

<p><code>sh
R CMD Rprof method1.out
R CMD Rprof method2.out
R CMD Rprof method3.out
</code></p>

<p>以<code>R CMD Rprof method1.out</code>的結果為例：</p>

<pre><code>Each sample represents 0.02 seconds.
Total run time: 168.98 seconds.

Total seconds: time spent in function and callees.
Self seconds: time spent in function alone.

   %       total       %        self
 total    seconds     self    seconds    name
 100.0    168.98       0.4      0.74     fun1
  99.4    167.98      99.4    167.98     rbind
   0.1      0.20       0.1      0.20     any
   0.0      0.04       0.0      0.04     is.na
   0.0      0.02       0.0      0.02     !


   %        self       %      total
  self    seconds    total   seconds    name
  99.4    167.98      99.4    167.98     rbind
   0.4      0.74     100.0    168.98     fun1
   0.1      0.20       0.1      0.20     any
   0.0      0.04       0.0      0.04     is.na
   0.0      0.02       0.0      0.02     !
</code></pre>

<p>這份報告共有兩個表格：</p>

<ul>
<li>表格一：

<ul>
<li><code>fun1</code>(進入到退出之間)總共花了168.98秒，佔總時間的100%，但是本身(扣除可以分割的部份)只花了0.74秒，佔0.4%</li>
<li><code>rbind</code>(進去到退出之間)花了167.98秒，佔總時間的99.4%，但是本身花了167.98秒，佔整體的99.4%</li>
</ul>
</li>
<li>表格二則和表格一類似，只是表格一是依照進入和退出間所佔的時間來排序，而表格二是依照本身的執行時間來排序。</li>
</ul>


<p>由此可知，我們只要能夠針對表格二的前面數列的函數進行優化，就可以大幅度改進程式效能。</p>

<p>接下來看<code>R CMD Rprof method2.out</code>的結果：</p>

<pre><code>Each sample represents 0.02 seconds.
Total run time: 0.58 seconds.

Total seconds: time spent in function and callees.
Self seconds: time spent in function alone.

   %       total       %        self
 total    seconds     self    seconds    name
 100.0      0.58      69.0      0.40     fun2
  13.8      0.08      13.8      0.08     any
  10.3      0.06      10.3      0.06     is.na
   3.4      0.02       3.4      0.02     !
   3.4      0.02       3.4      0.02     matrix


   %        self       %      total
  self    seconds    total   seconds    name
  69.0      0.40     100.0      0.58     fun2
  13.8      0.08      13.8      0.08     any
  10.3      0.06      10.3      0.06     is.na
   3.4      0.02       3.4      0.02     !
   3.4      0.02       3.4      0.02     matrix
</code></pre>

<p>這裡使用<code>matrix</code>來取代<code>rbind</code>之後，剩下效能的瓶頸就落在<code>any</code>上。
所以<code>fun3</code>更進一步的不使用<code>any</code>，得到：</p>

<pre><code>Each sample represents 0.02 seconds.
Total run time: 0.12 seconds.

Total seconds: time spent in function and callee
Self seconds: time spent in function alone.

   %       total       %        self
 total    seconds     self    seconds    name
 100.0      0.12      16.7      0.02     fun3
  66.7      0.08      66.7      0.08     |
  16.7      0.02      16.7      0.02     is.na


   %        self       %      total
  self    seconds    total   seconds    name
  66.7      0.08      66.7      0.08     |
  16.7      0.02     100.0      0.12     fun3
  16.7      0.02      16.7      0.02     is.na
</code></pre>

<p>可以看到效能又好了近5倍(0.12 : 0.58)！</p>

<h1>參考資料</h1>

<ul>
<li><a href="http://www.math.ncu.edu.tw/~chenwc/R_note/reference/debug/Rdebug.pdf">Rdebug</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
