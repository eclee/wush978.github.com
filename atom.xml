<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Work Work]]></title>
  <link href="http://wush978.github.com/atom.xml" rel="self"/>
  <link href="http://wush978.github.com/"/>
  <updated>2012-02-28T16:24:03+08:00</updated>
  <id>http://wush978.github.com/</id>
  <author>
    <name><![CDATA[Wush Wu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rcpp]]></title>
    <link href="http://wush978.github.com/blog/2012/02/28/rcpp/"/>
    <updated>2012-02-28T15:42:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/02/28/rcpp</id>
    <content type="html"><![CDATA[<h1>Rcpp 心得</h1>

<ul>
<li><p><a href="#overview">概述</a></p>

<ul>
<li><a href="#background">背景知識</a></li>
<li><a href="#introduction">介紹</a></li>
<li><a href="#install">安裝</a></li>
<li><a href="#compile">編譯</a></li>
<li><a href="#reference">參考資料</a></li>
</ul>
</li>
<li><p><a href="#syntax">語法</a></p>

<ul>
<li><a href="#R_Cplusplus">R to C++</a></li>
</ul>
</li>
</ul>


<hr />

<h2 id="overview"> 概述 </h2>




<h3 id="background"> 背景知識 </h3>


<p>就我所知，要能理解Rcpp的語法，你必須先對C++這個我個人認為最難學的語言先學到某種程度才行。根據<a href="http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876">Effective C++</a>的作者Scott Meyers的看法，C++其實是下列四種程式語言的集合(難怪很難，一個打四個!!):</p>

<ul>
<li>C的特性 (指標、陣列等等)</li>
<li>物件導向</li>
<li>STL 標準函式庫</li>
<li>Template</li>
</ul>


<p>Rcpp中大量的使用了後面三種，所以如果看不習慣Rcpp的使用者，可能得先回頭把C++後面三種的語法複習一下了。</p>

<h3 id="introduction"> 介紹 </h3>


<p><a href="http://dirk.eddelbuettel.com/code/rcpp.html">Rcpp</a> 是一個整合R和C++的library。
使用過R中的<code>.Call</code>函數的人一定會對於處理R和C之間資料結構的轉換感到很煩人，而Rcpp給我的第一個印象就是他把這些重複性很高的轉換給包起來了!所以在使用Rcpp時使用者不需要再去撰寫諸如以下的程式碼:</p>

<pre><code>/* return a R integer vector with R API */
#include &lt;R.h&gt;
#include &lt;Rdefines.h&gt;
SEXP foo() 
{
    SEXP retval;
    PROTECT(retval = NEW_INTEGER(2));
    INTEGER_POINTER(retval)[0] = 1;
    INTEGER_POINTER(retval)[1] = 2;
    UNPROTECT(1);
    return retval;
}
</code></pre>

<p>在Rcpp中, 透過C++的物件導向和template語法可以用下列的語法得到相同的效果：</p>

<pre><code>/* return a R integer vector with Rcpp */
#include &lt;Rcpp.h&gt;
RcppExport SEXP foo()
{
    Rcpp::IntegerVector retval(2);
    retval[0] = 1;
    retval[1] = 2;
    return Rcpp::wrap( retval );
}
</code></pre>

<p>比較上面兩段語法後，我基於以下的理由比較喜歡Rcpp的語法:</p>

<ol>
<li><p>Rcpp的語法比較簡潔。尤其是在比較<code>INTEGER_POINTER(retval)[0]</code>和<code>retval[0]</code>，
這種在真正寫功能時最常用到的語法，我比較喜歡使用後者。雖然你也可以再宣告一個指標:<code>int* retval_ptr = INTEGER_POINTER(retval)</code>
來達到類似的效果，但是對我來說, 明明都是代表<code>retval</code>這個物件，卻需要宣告兩個變數就是彆扭。</p></li>
<li><p>Rcpp可以使用更精確的型態。我認為比起<code>SEXP</code>或<code>NEW_INTEGER</code>，
<code>IntegerVector</code>是更清楚的，而且也更簡潔。除了<code>IntegerVector</code>外，Rcpp之中也定義了許許多多的型態，
甚至連<code>Matrix</code>、<code>Robj</code>(S4 object)和<code>environment</code>都有呢!</p></li>
<li><p>在物件導向的語法中我就可以依循<b>RAII(<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a>)</b>的原則來寫code，
降低了memory leak等資源洩漏的可能，也免除了使用<code>PROTECT</code>、<code>UNPROTECT</code>的困擾。</p></li>
</ol>


<p>介紹完Rcpp吸引我的理由後，接下來我就開始繼續紀錄我摸索Rcpp的點點滴滴啦。</p>
]]></content>
  </entry>
  
</feed>
