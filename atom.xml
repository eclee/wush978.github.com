<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://wush978.github.com/atom.xml" rel="self"/>
  <link href="http://wush978.github.com/"/>
  <updated>2012-02-28T16:04:13+08:00</updated>
  <id>http://wush978.github.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rcpp]]></title>
    <link href="http://wush978.github.com/blog/2012/02/28/rcpp/"/>
    <updated>2012-02-28T15:42:00+08:00</updated>
    <id>http://wush978.github.com/blog/2012/02/28/rcpp</id>
    <content type="html"><![CDATA[<h1>Rcpp 心得</h1>

<ul>
<li><p>[概述] (#overview)</p>

<ul>
<li>[背景知識] (#background)</li>
<li>[介紹] (#introduction)</li>
<li>[安裝] (#install)</li>
<li>[編譯] (#compile)</li>
<li>[參考資料] (#reference)</li>
</ul>
</li>
<li><p>[語法] (#syntax)</p>

<ul>
<li>[R to C++] (#R_Cplusplus)</li>
</ul>
</li>
</ul>


<hr />

<h2 id=overview>概述</h2>




<h3 id=background>背景知識</h3>


<p><a href="http://dirk.eddelbuettel.com/code/rcpp.html">Rcpp</a> 是一個整合R和C++的library。
使用過R中的<code>.Call</code>函數的人一定會對於處理R和C之間資料結構的轉換感到很煩人，而Rcpp給我的第一個印象就是他把這些重複性很高的轉換給包起來了!所以在使用Rcpp時使用者不需要再去撰寫諸如以下的程式碼:</p>

<pre><code>/* return a R integer vector with R API */
#include &lt;R.h&gt;
#include &lt;Rdefines.h&gt;
SEXP foo() 
{
    SEXP retval;
    PROTECT(retval = NEW_INTEGER(2));
    INTEGER_POINTER(retval)[0] = 1;
    INTEGER_POINTER(retval)[1] = 2;
    UNPROTECT(1);
    return retval;
}
</code></pre>

<p>在Rcpp中, 透過C++的物件導向和template語法可以用下列的語法得到相同的效果：</p>

<pre><code>/* return a R integer vector with Rcpp */
#include &lt;Rcpp.h&gt;
RcppExport SEXP foo()
{
    Rcpp::IntegerVector retval(2);
    retval[0] = 1;
    retval[1] = 2;
    return Rcpp::wrap( retval );
}
</code></pre>

<p>比較上面兩段語法後，我基於以下的理由比較喜歡Rcpp的語法:</p>

<ol>
<li><p>Rcpp的語法比較簡潔。尤其是在比較<code>INTEGER_POINTER(retval)[0]</code>和<code>retval[0]</code>，這種在真正寫功能時最常用到的語法，我比較喜歡使用後者。雖然你也可以再宣告一個指標:<code>int* retval_ptr = INTEGER_POINTER(retval)</code>來達到類似的效果，但是對我來說, 明明都是代表<code>retval</code>這個物件，卻需要宣告兩個變數就是彆扭。</p></li>
<li><p>Rcpp可以使用更精確的型態。我認為比起<code>SEXP</code>或<code>NEW_INTEGER</code>， <code>IntegerVector</code>是更清楚的，而且也更簡潔。除了<code>IntegerVector</code>外，Rcpp之中也定義了許許多多的型態，甚至連<code>Matrix</code>、<code>Robj</code>(S4 object)和<code>environment</code>都有呢!</p></li>
<li><p>在物件導向的語法中我就可以依循<b>RAII(<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a>)</b>的原則來寫code，降低了memory leak等資源洩漏的可能，也免除了使用<code>PROTECT</code>、<code>UNPROTECT</code>的困擾。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
